<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Crosswind Hold Trainer ‚Äî Web</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    :root {
      --bg: #0e1116;
      --ink: #e7e9ef;
      --muted: #a5adbd;
      --accent: #8ef5b1;
      --line: #1e2536;
      --reticle: #ff5252;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; background: var(--bg); color: var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { overflow: hidden; }

    /* Full-viewport stage */
    #stage {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: crosshair;
    }

    /* HUD chips */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      display: grid;
      grid-auto-flow: column;
      gap: 8px;
      z-index: 5;
    }
    .chip {
      background: rgba(255,255,255,0.06);
      border: 1px solid var(--line);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 13px;
      white-space: nowrap;
      user-select: none;
    }

    /* Controls */
    #controls {
      position: absolute;
      right: 10px;
      top: 10px;
      display: grid;
      grid-auto-flow: row;
      gap: 8px;
      z-index: 5;
    }
    .btn {
      background: #111823;
      border: 1px solid var(--line);
      color: var(--accent);
      padding: 8px 12px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    #footer {
      position: absolute;
      left: 50%;
      bottom: 14px;
      transform: translateX(-50%);
      display: grid;
      grid-auto-flow: column;
      gap: 10px;
      z-index: 5;
    }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="scope"></canvas>

    <div id="overlay">
      <div class="chip" id="hudWind">üí® Wind: ‚Äî mph FROM ‚Äî¬∞</div>
      <div class="chip" id="hudRange">üìè Range: ‚Äî yds</div>
      <div class="chip" id="hudTry">‚¨áÔ∏è Try DOPE: ‚Äî</div>
      <div class="chip" id="hudAvg">üìà Avg: 0.0 ‚Äî (0/10)</div>
      <div class="chip" id="hudScore">üéØ Score: 0 ‚Ä¢ High: 0</div>
    </div>

    <div id="controls">
      <button class="btn" id="btnUnits">UNIT: MIL</button>
      <button class="btn" id="btnReveal">REVEAL</button>
    </div>

    <div id="footer">
      <div class="chip" id="hudRound">Round 0/10</div>
    </div>
  </div>

  <script>
    // ====== Setup ======
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d');

    // HUD refs
    const $wind  = document.getElementById('hudWind');
    const $range = document.getElementById('hudRange');
    const $try   = document.getElementById('hudTry');
    const $avg   = document.getElementById('hudAvg');
    const $score = document.getElementById('hudScore');
    const $round = document.getElementById('hudRound');

    const $btnUnits  = document.getElementById('btnUnits');
    const $btnReveal = document.getElementById('btnReveal');

    // Device-pixel scaling
    function fitCanvas() {
      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width  = Math.round(rect.width  * dpr);
      canvas.height = Math.round(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      W = rect.width; H = rect.height;
    }

    let W = 0, H = 0, CX = 0, CY = 0;

    // ====== Model (aligned with app behavior) ======
    const ANGLE = { MIL: 'MIL', MOA: 'MOA' };
    let units = ANGLE.MIL;

    // App reticle extents (base MIL)
    const MAX_H_MIL = 6.0;   // ¬± horizontal
    const MAX_V_MIL = 12.0;  // vertical (downward rows)

    // Session state (minimal subset for the web trainer)
    let rangeYds = 600;
    let windMph = 10;
    let windFromDeg = 120;
    let trueElev = 0;  // in current units (computed from MIL table)
    let trueWindHold = 0; // in current units

    // Player guess (in current units)
    let guessH = 0.0; // RIGHT +
    let guessV = 0.0; // UP +

    // Reveal toggle
    let revealed = false;

    // Dope table (mil)
    const RANGE_PTS = [100,200,300,400,500,600,700,800,900,1000];
    const DOPE_MIL  = [0.0,0.5,1.1,1.9,3.0,4.2,5.6,7.1,8.8,10.6];

    function interpDopeMil(yd) {
      if (yd <= RANGE_PTS[0]) return DOPE_MIL[0];
      if (yd >= RANGE_PTS[RANGE_PTS.length-1]) return DOPE_MIL.at(-1);
      for (let i=0;i<RANGE_PTS.length-1;i++) {
        const x0=RANGE_PTS[i], x1=RANGE_PTS[i+1];
        if (yd >= x0 && yd <= x1) {
          const t = (yd - x0) / (x1 - x0);
          return DOPE_MIL[i] + t*(DOPE_MIL[i+1]-DOPE_MIL[i]);
        }
      }
      return DOPE_MIL[0];
    }

    const MOA_PER_MIL = 3.43774677;
    const toMOA = mil => mil * MOA_PER_MIL;
    const toMIL = moa => moa / MOA_PER_MIL;

    // Wind model (simple, app-like)
    function computeWindHoldMil(rangeYds, windMph, fromDeg, mphGun = 6.0) {
      const kyd = rangeYds / 1000.0;
      const s = Math.abs(Math.sin((fromDeg % 360) * Math.PI / 180.0));
      const sign = ((fromDeg % 360) < 180) ? 1 : -1;
      return (windMph / mphGun) * kyd * s * sign;
    }

    // Snap (0.1 mil or 0.25 MOA)
    function stepUnits() { return units === ANGLE.MIL ? 0.1 : 0.25; }
    function snap(val) { const s = stepUnits(); return Math.round(val / s) * s; }

    // Label helpers
    const oneDec = v => (Math.abs(v) < 0.05 ? '0.0' : v.toFixed(1));
    const dirH = v => `${oneDec(Math.abs(v))} ${v >= 0 ? 'RIGHT' : 'LEFT'}`;
    const dirV = v => `${oneDec(Math.abs(v))} ${v >= 0 ? 'UP' : 'DOWN'}`;

    // Mapping: units->px (respect base ¬±6H and 12V in MIL, then convert if MOA)
    let unitsPerPxX = 0.02, unitsPerPxY = 0.02; // updated each draw

    function pxPerUnitX() {
      const maxHX = (units === ANGLE.MIL) ? MAX_H_MIL : toMOA(MAX_H_MIL);
      const usableW = W - 24; // margin
      return usableW / (maxHX * 2.0);
    }
    function pxPerUnitY() {
      const maxVY = (units === ANGLE.MIL) ? MAX_V_MIL : toMOA(MAX_V_MIL);
      const usableH = H - 24;
      return usableH / (maxVY + 0.5); // cushion
    }

    // ====== Round init ======
    function newRound() {
      // fixed medium-difficulty sample; wire in RNG if desired
      rangeYds   = 600;
      windMph    = 10;
      windFromDeg= 120;

      const elevMil = interpDopeMil(rangeYds);
      const windMil = computeWindHoldMil(rangeYds, windMph, windFromDeg);

      if (units === ANGLE.MIL) {
        trueElev = elevMil;
        trueWindHold = windMil;
      } else {
        trueElev = toMOA(elevMil);
        trueWindHold = toMOA(windMil);
      }

      // Start at Try DOPE (V = true elev), H = 0
      guessH = 0.0;
      guessV = trueElev;

      revealed = false;
      updateHUD();
      draw();
    }

    // ====== Rendering ======
    function draw() {
      fitCanvas();
      CX = W / 2; CY = H / 2;

      const ppuX = pxPerUnitX();
      const ppuY = pxPerUnitY();
      unitsPerPxX = 1 / ppuX;
      unitsPerPxY = 1 / ppuY;

      // background
      ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
      ctx.fillRect(0, 0, W, H);

      // silhouette aligned so waterline (V=0) sits at CY
      drawIPSC(CX, CY, ppuX, ppuY);

      // Reticle translated by your guess
      const offX = guessH * ppuX;
      const offY = -(guessV) * ppuY; // UP positive
      ctx.save();
      ctx.translate(offX, offY);
      drawReticleTree(CX, CY, ppuX, ppuY);
      ctx.restore();

      // Reveal overlay (trace + true center)
      if (revealed) {
        const tx = CX + (trueWindHold * ppuX);
        const ty = CY - (trueElev * ppuY);
        const ux = CX + offX;
        const uy = CY + offY;

        // dashed trace
        ctx.setLineDash([6, 6]);
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(ux, uy);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        ctx.setLineDash([]);

        // your marker
        ctx.strokeStyle = '#0A84FF';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(ux - 10, uy); ctx.lineTo(ux + 10, uy);
        ctx.moveTo(ux, uy - 10); ctx.lineTo(ux, uy + 10);
        ctx.stroke();

        // true marker
        ctx.strokeStyle = '#E53935';
        ctx.lineWidth = 2.0;
        ctx.beginPath();
        ctx.moveTo(tx - 10, ty); ctx.lineTo(tx + 10, ty);
        ctx.moveTo(tx, ty - 10); ctx.lineTo(tx, ty + 10);
        ctx.stroke();
      }
    }

    function drawIPSC(cx, cy, ppuX, ppuY) {
      // scale target relative to range; this is visual only
      // width/h = 18"x30" projected ‚Äî approximate visual at 600 yd
      const inchToMil = (inches) => inches / (36.0 * (rangeYds/1000.0));
      const torsoWmil = inchToMil(18);
      const torsoHmil = inchToMil(30);

      const w = torsoWmil * ppuX;
      const h = torsoHmil * ppuY;

      // Position so waterline (60% from top) hits cy
      const waterFrac = 0.60;
      const top = cy - h * waterFrac;
      const left = cx - w / 2;

      // body
      ctx.fillStyle = '#1C2029';
      roundRect(left, top, w, h, 10, true, false);
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 1.6;
      roundRect(left, top, w, h, 10, false, true);

      // waterline
      ctx.strokeStyle = 'rgba(255,255,255,0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(left + w*0.04, cy);
      ctx.lineTo(left + w*0.96, cy);
      ctx.stroke();

      // aim dot
      ctx.fillStyle = 'rgba(255,255,255,0.75)';
      ctx.beginPath();
      ctx.arc(cx, cy, 3.2, 0, Math.PI*2);
      ctx.fill();

      // A-zone dashed (visual guide)
      const aWmil = inchToMil(6), aHmil = inchToMil(11), aTopOffMil = inchToMil(4);
      const aW = aWmil * ppuX, aH = aHmil * ppuY;
      const aTop = top + aTopOffMil * ppuY;
      dashedRect(cx - aW/2, aTop, aW, aH, 'rgba(255,255,255,0.18)');
    }

    function roundRect(x, y, w, h, r, fill, stroke) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.lineTo(x+w-rr,y);
      ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
      ctx.lineTo(x+w,y+h-rr);
      ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
      ctx.lineTo(x+rr,y+h);
      ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
      ctx.lineTo(x,y+rr);
      ctx.quadraticCurveTo(x,y,x+rr,y);
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function dashedRect(x,y,w,h,color) {
      ctx.save();
      ctx.setLineDash([7,7]);
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.0;
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }

    function drawReticleTree(cx, cy, ppuX, ppuY) {
      const isMOA = (units === ANGLE.MOA);
      const minor = isMOA ? 1.0 : 0.5;  // tick density
      const rowStep = isMOA ? 2 : 1;

      // main crosshair
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      ctx.moveTo(cx - (MAX_H_MIL * (isMOA?MOA_PER_MIL:1)) * ppuX - 8, cy);
      ctx.lineTo(cx + (MAX_H_MIL * (isMOA?MOA_PER_MIL:1)) * ppuX + 8, cy);
      ctx.stroke();

      // center tick
      ctx.beginPath();
      ctx.moveTo(cx-8, cy); ctx.lineTo(cx+8, cy);
      ctx.moveTo(cx, cy-8); ctx.lineTo(cx, cy+8);
      ctx.stroke();

      const maxHXUnits = (isMOA ? toMOA(MAX_H_MIL) : MAX_H_MIL);
      const maxVYUnits = (isMOA ? toMOA(MAX_V_MIL) : MAX_V_MIL);

      // center-line ticks + labels
      for (let u = -maxHXUnits; u <= maxHXUnits + 1e-6; u += minor) {
        const x = cx + u * ppuX;
        let len = 6, lw = 1.2, label = null;

        if (isMOA) {
          const au = Math.abs(u);
          if (Math.abs(au % 10) < 1e-6) { len = 16; lw = 2.0; label = au.toFixed(0); }
          else if (Math.abs(au % 5) < 1e-6) { len = 13; lw = 1.6; }
          else if (Math.abs(au % 2) < 1e-6) { len = 10; lw = 1.4; }
        } else {
          if (Math.abs(u % 1.0) < 1e-6) { len = 12; lw = 1.6; label = Math.abs(u).toFixed(0); }
        }

        ctx.strokeStyle = 'rgba(255,255,255,0.88)';
        ctx.lineWidth = lw;
        ctx.beginPath();
        ctx.moveTo(x, cy - len/2); ctx.lineTo(x, cy + len/2);
        ctx.stroke();

        if (label && Math.abs(u) > 1e-6) {
          ctx.fillStyle = 'rgba(225,230,240,0.95)';
          ctx.font = '12px ui-monospace,monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(label, x, cy + 14);
        }
      }

      // tree rows up/down
      const maxRow = Math.floor(maxVYUnits);
      for (let row = rowStep; row <= maxRow; row += rowStep) {
        const yDown = cy + row * ppuY;
        const yUp   = cy - row * ppuY;
        const branchUnits = maxHXUnits * (row / maxVYUnits);
        const xL = cx - branchUnits * ppuX;
        const xR = cx + branchUnits * ppuX;

        // row line
        ctx.strokeStyle = isMOA
          ? (row % 10 === 0 ? 'rgba(255,255,255,1.0)' : row % 5 === 0 ? 'rgba(255,255,255,0.85)' : 'rgba(255,255,255,0.7)')
          : 'rgba(255,255,255,0.8)';
        ctx.lineWidth = isMOA ? (row % 10 === 0 ? 2.0 : row % 5 === 0 ? 1.6 : 1.2) : 1.2;
        ctx.beginPath(); ctx.moveTo(xL, yDown); ctx.lineTo(xR, yDown); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xL, yUp);   ctx.lineTo(xR, yUp);   ctx.stroke();

        // ticks across branch
        for (let u = -branchUnits; u <= branchUnits + 1e-6; u += minor) {
          const absu = Math.abs(u);
          const x = cx + u * ppuX;

          let len = isMOA ? 5 : 4, lw = 1.0;
          if (isMOA) {
            if (Math.abs(absu % 10) < 1e-6) { len = 11; lw = 1.6; }
            else if (Math.abs(absu % 5) < 1e-6) { len = 9; lw = 1.4; }
            else if (Math.abs(absu % 2) < 1e-6) { len = 7; lw = 1.2; }
          } else {
            if (Math.abs(absu % 1.0) < 1e-6) { len = 8; lw = 1.2; }
          }

          ctx.strokeStyle = 'rgba(255,255,255,0.85)';
          ctx.lineWidth = lw;
          // down row
          ctx.beginPath(); ctx.moveTo(x, yDown - len/2); ctx.lineTo(x, yDown + len/2); ctx.stroke();
          // up row
          ctx.beginPath(); ctx.moveTo(x, yUp - len/2);   ctx.lineTo(x, yUp + len/2);   ctx.stroke();
        }

        // row labels at majors
        const showLabel = isMOA ? (row % 10 === 0) : true;
        if (showLabel) {
          ctx.fillStyle = 'rgba(225,230,240,0.95)';
          ctx.font = '12px ui-monospace,monospace';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'bottom';
          ctx.fillText(String(row), xL - 10, yDown - 6);
          ctx.textBaseline = 'top';
          ctx.fillText(String(-row), xL - 10, yUp + 6);
        }
      }

      // unit tag
      ctx.fillStyle = 'rgba(225,230,240,0.95)';
      ctx.font = '12px ui-monospace,monospace';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText(units, cx - (maxHXUnits + 0.6) * ppuX, cy - 10);
    }

    // ====== HUD + interactions ======
    function updateHUD() {
      $wind.textContent  = `üí® Wind: ${windMph.toFixed(0)} mph FROM ${windFromDeg.toFixed(0)}¬∞`;
      $range.textContent = `üìè Range: ${rangeYds} yds`;
      $try.textContent   = `‚¨áÔ∏è Try DOPE: ${dirV(guessV)} ${units}`;
      $avg.textContent   = `üìà Avg: 0.0 ${units} (0/10)`;
      $score.textContent = `üéØ Score: 0 ‚Ä¢ High: 0`;
      $round.textContent = `Round 0/10`;
    }

    // drag (mouse + touch)
    let dragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragOrigin = { h: 0, v: 0 };

    function startDrag(x, y) {
      dragging = true;
      dragStart.x = x; dragStart.y = y;
      dragOrigin.h = guessH; dragOrigin.v = guessV;
    }
    function moveDrag(x, y) {
      if (!dragging) return;
      const dx = (x - dragStart.x) * unitsPerPxX;
      const dy = (y - dragStart.y) * unitsPerPxY;
      const maxH = (units === ANGLE.MIL) ? MAX_H_MIL : toMOA(MAX_H_MIL);
      const maxV = (units === ANGLE.MIL) ? MAX_V_MIL : toMOA(MAX_V_MIL);
      guessH = Math.max(-maxH, Math.min(maxH, dragOrigin.h + dx));
      guessV = Math.max(-maxV, Math.min(maxV, dragOrigin.v - dy)); // screen Y down -> V up
      draw();
      updateHUD();
    }
    function endDrag() {
      if (!dragging) return;
      dragging = false;
      guessH = snap(guessH);
      guessV = snap(guessV);
      draw();
      updateHUD();
    }

    canvas.addEventListener('mousedown', e => startDrag(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => moveDrag(e.clientX, e.clientY));
    window.addEventListener('mouseup', endDrag);

    canvas.addEventListener('touchstart', e => {
      const t = e.changedTouches[0]; startDrag(t.clientX, t.clientY);
    }, { passive: true });
    window.addEventListener('touchmove', e => {
      const t = e.changedTouches[0]; moveDrag(t.clientX, t.clientY);
    }, { passive: true });
    window.addEventListener('touchend', endDrag);

    // Units toggle
    $btnUnits.addEventListener('click', () => {
      // convert current state
      if (units === ANGLE.MIL) {
        units = ANGLE.MOA;
        guessH = toMOA(guessH);
        guessV = toMOA(guessV);
        trueElev = toMOA(toMIL(trueElev)); // ensure idempotence
        trueWindHold = toMOA(toMIL(trueWindHold));
      } else {
        units = ANGLE.MIL;
        guessH = toMIL(guessH);
        guessV = toMIL(guessV);
        trueElev = toMIL(trueElev);
        trueWindHold = toMIL(trueWindHold);
      }
      $btnUnits.textContent = `UNIT: ${units}`;
      draw();
      updateHUD();
    });

    // Reveal toggle
    $btnReveal.addEventListener('click', () => {
      revealed = !revealed;
      $btnReveal.textContent = revealed ? 'HIDE' : 'REVEAL';
      draw();
    });

    // Boot
    fitCanvas();
    newRound();

    // Resize
    window.addEventListener('resize', () => { draw(); });
  </script>
</body>
</html>
