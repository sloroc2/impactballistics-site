<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cross‑Wind Challenge</title>
  <style>
    :root {
      --bg: #0f1116;
      --panel: #151925;
      --ink: #e7e9ef;
      --muted: #a5adbd;
      --accent: #8ef5b1; /* your brand pop */
      --danger: #ff6b6b;
      --ok: #4cd137;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { background: var(--bg); color: var(--ink); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display: grid; grid-template-columns: 1fr 360px; gap: 12px; height: 100%; padding: 12px; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; grid-template-rows: auto 1fr; } }
    .stage { background: #0b0d13; border: 1px solid #1e2536; border-radius: 14px; position: relative; display: flex; align-items: center; justify-content: center; }
    canvas { width: 100%; height: 100%; display: block; border-radius: 14px; }
    .side { background: var(--panel); border: 1px solid #1e2536; border-radius: 14px; padding: 14px; display: grid; grid-auto-rows: min-content; gap: 12px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
    .row > * + * { margin-left: 8px; }
    .pill { background: #0f1422; border: 1px solid #222a3d; color: var(--ink); border-radius: 999px; padding: 8px 12px; }
    .btn { cursor: pointer; user-select: none; background: #0c1520; border: 1px solid #23314a; color: var(--ink); padding: 10px 12px; border-radius: 10px; font-weight: 600; }
    .btn:hover { border-color: #2f4162; }
    .btn.prim { background: #0f1c16; border-color: #214636; color: var(--accent); }
    .btn.danger { background: #1f1111; border-color: #4a2323; color: var(--danger); }
    .kv { display: grid; grid-template-columns: auto 1fr; gap: 4px 10px; }
    .kv div:nth-child(odd) { color: var(--muted); }
    .hr { height: 1px; background: #222a3d; margin: 4px 0; }
    .score { font-size: 28px; font-weight: 800; letter-spacing: 0.5px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color: var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <canvas id="scope"></canvas>
    </div>
    <aside class="side">
      <div class="row">
        <button id="new" class="btn prim">New Round</button>
        <button id="reveal" class="btn">Reveal</button>
        <button id="next" class="btn" disabled>Next</button>
      </div>
      <div class="row">
        <button id="units" class="btn pill">Units: <span id="unitsLabel">MIL</span></button>
        <button id="mode" class="btn pill">Mode: <span id="modeLabel">Centerfire</span></button>
      </div>

      <div class="kv mono">
        <div>Range</div><div><span id="range">—</span> yd</div>
        <div>Wind</div><div><span id="wind">—</span> mph from <span id="from">—</span>°</div>
        <div>TRY Elev</div><div><span id="tryV">—</span></div>
        <div>TRY Wind</div><div><span id="tryH">—</span></div>
      </div>
      <div class="hr"></div>
      <div class="kv mono">
        <div>TRUE Elev</div><div><span id="trueV">—</span></div>
        <div>TRUE Wind</div><div><span id="trueH">—</span></div>
        <div>Result</div><div><span id="res">—</span></div>
      </div>
      <div class="hr"></div>
      <div class="row">
        <div class="score">Score: <span id="score">0</span></div>
        <div class="muted">Round <span id="round">0</span>/10</div>
      </div>
      <div class="muted">Drag inside the scope to set your hold. Space = Reveal/Next.</div>
    </aside>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d', { alpha: true });

    // UI hooks
    const el = id => document.getElementById(id);
    const lbl = {
      range: el('range'), wind: el('wind'), from: el('from'), tryV: el('tryV'), tryH: el('tryH'),
      trueV: el('trueV'), trueH: el('trueH'), res: el('res'), score: el('score'), round: el('round'),
      units: el('units'), unitsLabel: el('unitsLabel'), mode: el('mode'), modeLabel: el('modeLabel'),
      btnNew: el('new'), btnReveal: el('reveal'), btnNext: el('next')
    };

    // Constants (mirrors the app logic)
    const MAX_H_MIL = 6.0;   // ± horizontal
    const MAX_V_MIL = 12.0;  // downward rows
    const MARGIN_PX = 12;
    const MAP_CUSHION_UNITS = 0.5;
    const MOA_PER_MIL = 3.437746770784939; // precise

    // IPSC torso for scoring (inches)
    const IPSC_W_IN = 18.0, IPSC_H_IN = 30.0;
    const A_W_IN = 6.0, A_H_IN = 11.0, A_TOP_OFFSET_IN = 4.0; // top inset from torso top
    const D_MARGIN_IN = 3.0; // thickened edge band for D

    // DOPE baseline (MIL) for centerfire (illustrative .540 G1)
    const RANGE_PTS = [100,200,300,400,500,600,700,800,900,1000];
    const DOPE_MIL = [0.0,0.5,1.1,1.9,3.0,4.2,5.6,7.1,8.8,10.6];

    // State
    let dark = true;
    let units = 'MIL'; // 'MIL' or 'MOA'
    let mode = 'CF';   // 'CF' or 'RF'

    let game = {
      round: 0, totalScore: 0, revealed: false, hintUsed: false,
      isRimfire: false,
      mphGun: 6.0, includeSpin: false,
      rangeYds: 400, windMph: 10, windFrom: 270,
      trueElev: 0, trueWind: 0,
      guessH: 0, guessV: 0
    };

    // Viewport mapping
    let pxPerUnitX = 10, pxPerUnitY = 10;
    let unitsPerPxX = 0.1, unitsPerPxY = 0.1;
    let dragStart = null; // {x,y,h,v}

    function resize() {
      const r = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      draw();
    }
    window.addEventListener('resize', resize, { passive: true });

    // Helpers
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const toMOA = mil => mil * MOA_PER_MIL;
    const toMIL = moa => moa / MOA_PER_MIL;
    const snap1 = v => Math.round(v * 10) / 10; // one decimal like the app

    function pickDistanceYds(isRF) {
      const minY = isRF ? 100 : 100;
      const maxY = isRF ? 400 : 1000;
      const steps = Math.floor((maxY - minY) / 50);
      const r = minY + Math.floor(Math.random() * (steps + 1)) * 50;
      return r;
    }

    function tryDopeMil(rangeYds) {
      if (rangeYds <= RANGE_PTS[0]) return DOPE_MIL[0];
      if (rangeYds >= RANGE_PTS[RANGE_PTS.length-1]) return DOPE_MIL[DOPE_MIL.length-1];
      for (let i=0;i<RANGE_PTS.length-1;i++){
        const x0 = RANGE_PTS[i], x1 = RANGE_PTS[i+1];
        if (rangeYds >= x0 && rangeYds <= x1){
          const y0 = DOPE_MIL[i], y1 = DOPE_MIL[i+1];
          const t = (rangeYds - x0) / (x1 - x0);
          return y0 + t * (y1 - y0);
        }
      }
      return DOPE_MIL[DOPE_MIL.length-1];
    }

    function mphFromRimfireVelocity(fps){
      const table = [ [900,1.0],[980,1.2],[1040,1.4],[1100,1.7],[1200,2.1],[1300,2.5],[1500,3.0] ];
      if (fps <= table[0][0]) return table[0][1];
      if (fps >= table[table.length-1][0]) return table[table.length-1][1];
      for (let i=0;i<table.length-1;i++){
        const [x0,y0] = table[i]; const [x1,y1] = table[i+1];
        if (fps >= x0 && fps <= x1){
          const t = (fps - x0) / (x1 - x0);
          return Math.round((y0 + t*(y1-y0))*100)/100;
        }
      }
      return 2.0;
    }

    function computeWindHoldMil(rangeYds, windMph, fromDeg){
      const mphGun = game.mphGun > 0 ? game.mphGun : 6.0;
      const rangeKyd = rangeYds / 1000.0;
      const s = Math.abs(Math.sin(((fromDeg % 360) * Math.PI) / 180.0));
      const sign = ((fromDeg % 360) < 180.0) ? 1.0 : -1.0; // 0..179 pushes right (+)
      let mil = (windMph / mphGun) * rangeKyd * s * sign;
      if (game.includeSpin){
        mil += 0.00007 * Math.pow(rangeYds, 1.2) * 1.0; // RH twist
      }
      return mil;
    }

    function inchesToMilAtRange(inches, rangeYds){
      const yardsToInches = rangeYds * 36.0;
      const milsPerInch = 1000.0 / yardsToInches;
      return inches * milsPerInch;
    }

    function scoreZone(dxMil, dyMil, rangeYds){
      const jitterPad = 0.12;
      const halfW = inchesToMilAtRange(IPSC_W_IN/2.0, rangeYds) + jitterPad;
      const halfH = inchesToMilAtRange(IPSC_H_IN/2.0, rangeYds) + jitterPad;
      const torsoTopOffsetMil = inchesToMilAtRange(IPSC_W_IN*0.40, rangeYds);
      const torsoCenterYMil = torsoTopOffsetMil - halfH + jitterPad;
      const lx = dxMil;
      const ly = dyMil - torsoCenterYMil;

      const inTorso = (lx>=-halfW && lx<=halfW && ly>=-halfH && ly<=halfH);
      if (!inTorso) return 'MISS';

      const aHalfW = inchesToMilAtRange(A_W_IN/2.0, rangeYds);
      const aHalfH = inchesToMilAtRange(A_H_IN/2.0, rangeYds);
      const aCenterY = (halfH - inchesToMilAtRange(A_TOP_OFFSET_IN, rangeYds)) - aHalfH;
      const inA = (Math.abs(lx)<=aHalfW && Math.abs(ly - aCenterY)<=aHalfH);
      if (inA) return 'A';

      const dInsetX = Math.max(0, inchesToMilAtRange(D_MARGIN_IN, rangeYds) - (jitterPad*0.5));
      const dInsetY = Math.max(0, inchesToMilAtRange(D_MARGIN_IN, rangeYds) - (jitterPad*0.5));
      const nearLeft  = lx < -halfW + dInsetX;
      const nearRight = lx >  halfW - dInsetX;
      const nearTop   = ly >  halfH - dInsetY;
      const nearBot   = ly < -halfH + dInsetY;
      const inD = nearLeft || nearRight || nearTop || nearBot;
      if (inD) return 'D';

      return 'C';
    }

    function startRound(){
      game.round = (game.round % 10) + 1;
      game.revealed = false; game.hintUsed = false;
      game.isRimfire = (mode === 'RF');

      game.rangeYds = pickDistanceYds(game.isRimfire);
      game.windMph = 2 + Math.floor(Math.random()*19);
      const bands = [ [60,120],[240,300],[0,360] ];
      const b = Math.random()<0.7 ? bands[Math.floor(Math.random()*2)] : bands[2];
      game.windFrom = Math.random()*(b[1]-b[0]) + b[0];

      if (game.isRimfire){
        game.mphGun = mphFromRimfireVelocity(1080); // default RF auto mph‑gun baseline
      } else {
        game.mphGun = 6.0; // CF default if no BC provided (can tune later)
      }

      const elevMil = tryDopeMil(game.rangeYds);
      game.trueElev = (units==='MIL') ? elevMil : toMOA(elevMil);
      const trueWindMil = computeWindHoldMil(game.rangeYds, game.windMph, game.windFrom);
      game.trueWind = (units==='MIL') ? trueWindMil : toMOA(trueWindMil);

      game.guessH = 0.0;
      game.guessV = game.trueElev;

      lbl.round.textContent = game.round;
      updateLabels();
      draw();
    }

    function reveal(){
      if (game.revealed) return;
      game.revealed = true;
      const hMil = (units==='MIL') ? game.guessH : toMIL(game.guessH);
      const vMil = (units==='MIL') ? game.guessV : toMIL(game.guessV);
      const trueHMil = (units==='MIL') ? game.trueWind : toMIL(game.trueWind);
      const trueVMil = (units==='MIL') ? game.trueElev : toMIL(game.trueElev);

      const dx = hMil - trueHMil;
      const dy = vMil - trueVMil;
      const zone = scoreZone(dx, dy, game.rangeYds);
      lbl.res.textContent = zone;

      const points = zone==='A'?100: zone==='C'?70: zone==='D'?40: 0;
      // normalize to MIL sessions for high score consistency (mil-normalized is fine for now)
      game.totalScore += points;
      lbl.score.textContent = game.totalScore;

      lbl.btnReveal.disabled = true;
      lbl.btnNext.disabled = false;
      draw();
    }

    function next(){
      lbl.btnReveal.disabled = false;
      lbl.btnNext.disabled = true;
      startRound();
    }

    function updateLabels(){
      lbl.range.textContent = game.rangeYds.toFixed(0);
      lbl.wind.textContent = game.windMph.toFixed(0);
      lbl.from.textContent = game.windFrom.toFixed(0);
      lbl.tryV.textContent = snap1(game.guessV).toFixed(1) + ' ' + units;
      lbl.tryH.textContent = snap1(game.guessH).toFixed(1) + ' ' + units;
      if (game.revealed){
        lbl.trueV.textContent = snap1(game.trueV).toFixed(1) + ' ' + units;
        lbl.trueH.textContent = snap1(game.trueWind).toFixed(1) + ' ' + units;
      } else {
        lbl.trueV.textContent = '—';
        lbl.trueH.textContent = '—';
        lbl.res.textContent = '—';
      }
    }

    // Pointer handling → drag reticle offset (in UNITS)
    function unitExtent(){
      const maxHX = (units==='MIL') ? MAX_H_MIL : toMOA(MAX_H_MIL);
      const maxVY = (units==='MIL') ? MAX_V_MIL : toMOA(MAX_V_MIL);
      return { maxHX, maxVY };
    }

    function mapUnits(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      const cx = w/2, cy = h/2;
      const { maxHX, maxVY } = unitExtent();
      const pxW = (w - 2*MARGIN_PX) / (maxHX*2);
      const pxH = (h - 2*MARGIN_PX) / (maxVY + MAP_CUSHION_UNITS);
      pxPerUnitX = pxW; pxPerUnitY = pxH;
      unitsPerPxX = 1/pxPerUnitX; unitsPerPxY = 1/pxPerUnitY;
      return { cx, cy };
    }

    function onPointerDown(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
      dragStart = { x, y, h: game.guessH, v: game.guessV };
    }
    function onPointerMove(e){ if (!dragStart) return; dragTo(e); }
    function onPointerUp(){ dragStart = null; }

    function dragTo(e){
      const rect = canvas.getBoundingClientRect();
      const x = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
      const y = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
      const dx = (x - dragStart.x) * unitsPerPxX;
      const dy = (y - dragStart.y) * unitsPerPxY;
      const { maxHX, maxVY } = unitExtent();
      // Horizontal → wind hold; Vertical → elevation
      game.guessH = clamp(snap1(dragStart.h + dx), -maxHX, maxHX);
      game.guessV = clamp(snap1(dragStart.v + dy), 0, maxVY);
      updateLabels();
      draw();
    }

    canvas.addEventListener('mousedown', onPointerDown);
    canvas.addEventListener('mousemove', onPointerMove);
    window.addEventListener('mouseup', onPointerUp);
    canvas.addEventListener('touchstart', onPointerDown, { passive: true });
    canvas.addEventListener('touchmove', onPointerMove, { passive: true });
    canvas.addEventListener('touchend', onPointerUp, { passive: true });

    // Drawing
    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      const { cx, cy } = mapUnits();

      // scope disk
      const r = Math.min(w,h)/2 - 2;
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI*2);
      ctx.clip();

      ctx.fillStyle = dark ? '#0F1116' : '#F6F7FB';
      ctx.fillRect(0,0,w,h);

      // grid/reticle tree
      drawReticle(cx, cy);

      // ghost marker at center when dragging
      if (dragStart){
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.beginPath(); ctx.arc(cx, cy, 2.5, 0, Math.PI*2); ctx.fill();
      }

      // reveal: draw true impact vs guessed
      if (game.revealed){
        const gh = game.guessH, gv = game.guessV; // in current units
        const th = game.trueWind, tv = game.trueElev;
        // Guess mark
        dot(cx + gh*pxPerUnitX, cy + gv*pxPerUnitY, 4, '#ffcc00');
        // True mark
        dot(cx + th*pxPerUnitX, cy + tv*pxPerUnitY, 4, '#4cd137');
      } else {
        // live guess dot
        const gh = game.guessH, gv = game.guessV;
        dot(cx + gh*pxPerUnitX, cy + gv*pxPerUnitY, 4, '#8ef5b1');
      }

      // wind dial overlay (top‑left)
      drawWindDial(16, 16, 70);

      ctx.restore();

      // circular border
      ctx.strokeStyle = '#1e2536'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
    }

    function dot(x,y,rad,color){ ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fill(); }

    function drawReticle(cx,cy){
      const isMOA = (units==='MOA');
      const maxHX = (units==='MIL') ? MAX_H_MIL : toMOA(MAX_H_MIL);
      const maxVY = (units==='MIL') ? MAX_V_MIL : toMOA(MAX_V_MIL);

      // zero/waterline
      ctx.strokeStyle = '#ffffff30'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(cx - maxHX*pxPerUnitX, cy); ctx.lineTo(cx + maxHX*pxPerUnitX, cy); ctx.stroke();

      // center vertical
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy + maxVY*pxPerUnitY); ctx.stroke();

      // ticks & labels
      ctx.fillStyle = '#a5adbd';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = '12px ui-monospace, monospace';

      const step = isMOA ? 1 : 0.5; // minor spacing
      for (let u = step; u <= maxHX; u += step){ // horizontal ticks both sides
        const major = isMOA ? (Math.abs(u % 10) < 1e-6) : (Math.abs(u % 1) < 1e-6);
        const len = major ? 16 : (isMOA && Math.abs(u % 5) < 1e-6 ? 12 : 8);
        // right
        strokeLine(cx + u*pxPerUnitX, cy - len/2, cx + u*pxPerUnitX, cy + len/2, major?1.2:0.8, major?'#ffffff99':'#ffffff70');
        // left
        strokeLine(cx - u*pxPerUnitX, cy - len/2, cx - u*pxPerUnitX, cy + len/2, major?1.2:0.8, major?'#ffffff99':'#ffffff70');
        // labels (major only)
        if (major){
          textAt((isMOA?u:Math.round(u)).toString(), cx + u*pxPerUnitX, cy - 12);
          textAt((isMOA?u:Math.round(u)).toString(), cx - u*pxPerUnitX, cy - 12);
        }
      }

      // vertical rows each 1 MIL (or 2 MOA) with chevrons
      const rowStep = isMOA ? 2 : 1;
      const chevronEvery = isMOA ? 10 : 2;
      for (let v=rowStep; v<=maxVY; v+=rowStep){
        // row line
        strokeLine(cx - maxHX*pxPerUnitX, cy + v*pxPerUnitY, cx + maxHX*pxPerUnitX, cy + v*pxPerUnitY, 1, '#ffffff50');
        // chevrons
        if ((v % chevronEvery) === 0){
          chevron(cx, cy + v*pxPerUnitY, 10);
          textAt(String(v), cx - maxHX*pxPerUnitX + 12, cy + v*pxPerUnitY - 10, 'left');
        }
      }

      // IPSC outline aligned to waterline for visual feedback
      drawIPSC(cx, cy, game.rangeYds);
    }

    function strokeLine(x1,y1,x2,y2,w,color){ ctx.strokeStyle=color; ctx.lineWidth=w; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }

    function textAt(t, x, y, align='center'){ ctx.save(); ctx.fillStyle='#a5adbd'; ctx.textAlign=align; ctx.textBaseline='middle'; ctx.fillText(t,x,y); ctx.restore(); }

    function chevron(x,y,s){ ctx.save(); ctx.strokeStyle='#ffffff99'; ctx.lineWidth=1.4; ctx.beginPath(); ctx.moveTo(x-s, y+s); ctx.lineTo(x, y); ctx.lineTo(x+s, y+s); ctx.stroke(); ctx.restore(); }

    function drawIPSC(cx, cy, rangeYds){
      // map inches→mil→px
      const halfW = inchesToMilAtRange(IPSC_W_IN/2.0, rangeYds) * pxPerUnitX;
      const halfH = inchesToMilAtRange(IPSC_H_IN/2.0, rangeYds) * pxPerUnitY;
      const topOffset = inchesToMilAtRange(IPSC_W_IN*0.40, rangeYds) * pxPerUnitY; // waterline ~60% down
      const torsoCenterY = cy + (topOffset - halfH);

      ctx.save();
      ctx.strokeStyle = '#ffffff22'; ctx.lineWidth = 1;
      ctx.strokeRect(cx - halfW, torsoCenterY - halfH, halfW*2, halfH*2);

      // A‑zone
      const aHalfW = inchesToMilAtRange(A_W_IN/2.0, rangeYds) * pxPerUnitX;
      const aHalfH = inchesToMilAtRange(A_H_IN/2.0, rangeYds) * pxPerUnitY;
      const aTop = torsoCenterY - halfH + inchesToMilAtRange(A_TOP_OFFSET_IN, rangeYds) * pxPerUnitY;
      const aCy = aTop + aHalfH;
      ctx.strokeStyle = '#ffffff44';
      ctx.strokeRect(cx - aHalfW, aCy - aHalfH, aHalfW*2, aHalfH*2);
      ctx.restore();
    }

    function drawWindDial(x,y,s){
      ctx.save();
      ctx.translate(x+s, y+s);
      ctx.fillStyle = '#0b0d13'; ctx.strokeStyle = '#1e2536'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(0,0,s,0,Math.PI*2); ctx.fill(); ctx.stroke();
      // ticks
      for (let a=0; a<360; a+=30){
        const rad = a*Math.PI/180; const r1 = s-8, r2 = s-2;
        ctx.strokeStyle = '#ffffff22'; ctx.beginPath();
        ctx.moveTo(Math.cos(rad)*r1, Math.sin(rad)*r1);
        ctx.lineTo(Math.cos(rad)*r2, Math.sin(rad)*r2);
        ctx.stroke();
      }
      // from‑arrow
      const th = (game.windFrom-90) * Math.PI/180; // rotate to canvas coords
      ctx.strokeStyle = '#8ef5b1'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(Math.cos(th)*(s-20), Math.sin(th)*(s-20)); ctx.lineTo(0,0); ctx.stroke();
      // text
      ctx.fillStyle = '#a5adbd'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='12px ui-monospace, monospace';
      ctx.fillText(`${game.windMph} mph`, 0, 0);
      ctx.restore();
    }

    // Controls
    lbl.units.onclick = () => {
      units = (units==='MIL') ? 'MOA' : 'MIL';
      lbl.unitsLabel.textContent = units;
      // convert current guesses/true to new unit so they stay visually consistent
      if (units==='MOA'){ game.guessH = toMOA(game.guessH); game.guessV = toMOA(game.guessV); game.trueWind = toMOA(game.trueWind); game.trueElev = toMOA(game.trueElev); }
      else { game.guessH = toMIL(game.guessH); game.guessV = toMIL(game.guessV); game.trueWind = toMIL(game.trueWind); game.trueElev = toMIL(game.trueElev); }
      updateLabels(); draw();
    };

    lbl.mode.onclick = () => {
      mode = (mode==='CF') ? 'RF' : 'CF';
      lbl.modeLabel.textContent = (mode==='CF') ? 'Centerfire' : 'Rimfire';
      next();
    };

    lbl.btnNew.onclick = () => { game.round = 0; game.totalScore = 0; lbl.score.textContent = '0'; next(); };
    lbl.btnReveal.onclick = () => reveal();
    lbl.btnNext.onclick = () => next();

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); if (!game.revealed) reveal(); else next(); }
      if (e.key === 'm' || e.key === 'M') lbl.units.click();
    });

    // Kick
    resize();
    next();
  })();
  </script>
</body>
</html>
