<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Wind Hold Trainer ‚Äî Web Replica</title>
  <style>
    :root { --bg:#0e1116; --ink:#e7e9ef; --muted:#a5adbd; --accent:#8ef5b1; --line:#1e2536; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:grid;grid-template-rows:min-content 1fr min-content;height:100%}
    .hud{display:grid;grid-auto-flow:column;gap:10px;padding:12px;justify-content:start}
    .pill{background:#0f1422;border:1px solid var(--line);border-radius:12px;padding:10px 12px;color:var(--ink)}
    .pill strong{font-weight:700}
    .stage{position:relative;width:100%;height:calc(100vh - 170px);min-height:560px}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
    .footer{display:grid;grid-template-columns:1fr auto auto;gap:12px;padding:12px;align-items:center}
    .btn{cursor:pointer;background:#0c1520;border:1px solid var(--line);color:var(--ink);padding:12px 14px;border-radius:14px;font-weight:700}
    .btn.primary{background:#0f1c16;border-color:#214636;color:var(--accent)}
    .btn.warn{background:#1d1414;border-color:#3b2323;color:#ff8a8a}
    @media (max-width:900px){.stage{height:calc(100vh - 220px)}.hud{grid-auto-flow:row;grid-template-columns:repeat(2,minmax(0,1fr))}.footer{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="pill">üí® <strong>Wind:</strong> <span id="wind">‚Äî</span> mph FROM <span id="from">‚Äî</span>¬∞</div>
      <div class="pill">üìè <strong>Range:</strong> <span id="range">‚Äî</span> yds</div>
      <div class="pill">‚¨áÔ∏è <strong>Try DOPE:</strong> <span id="tryV">‚Äî</span> UP</div>
      <div class="pill">üìà <strong>Avg:</strong> <span id="avg">0.0</span> <span id="unitsAvg">MIL</span> (<span id="shotIdx">0</span>/10)</div>
      <div class="pill">üéØ <strong>Score:</strong> <span id="score">0</span> ‚Ä¢ High: <span id="high">0</span></div>
      <div class="pill">‚öôÔ∏è <strong><span id="unitsLabel">MIL</span></strong> ‚Ä¢ <span id="modeLabel">Centerfire</span></div>
    </div>

    <div class="stage"><canvas id="scope"></canvas></div>

    <div class="footer">
      <div style="font-weight:800">Round <span id="round">0</span>/10</div>
      <div style="display:flex;gap:10px">
        <button id="hint" class="btn">üí° Hint (‚àí50%)</button>
        <button id="reveal" class="btn primary">üëÅÔ∏è Reveal</button>
      </div>
      <div style="display:flex;gap:10px">
        <button id="toggleUnits" class="btn">Toggle MIL/MOA</button>
        <button id="toggleMode" class="btn">Centerfire/Rimfire</button>
        <button id="newRound" class="btn warn">New Session</button>
      </div>
    </div>
  </div>

  <script>
  (()=>{
    // ===== Constants (mirror Dart) =====
    const MOA_PER_MIL = 3.43774677;
    const MAX_H_MIL = 6.0, MAX_V_MIL = 12.0;
    const MARGIN_PX = 12.0, MAP_CUSHION_UNITS = 0.5; // painter mapping
    const JITTER_MIL = 0.12;

    const RANGES=[100,200,300,400,500,600,700,800,900,1000];
    const DOPE_MIL=[0.0,0.5,1.1,1.9,3.0,4.2,5.6,7.1,8.8,10.6];

    const IPSC={W:18,H:30,A_W:6,A_H:11,A_TOP:4,D:3};

    // ===== State =====
    let units='MIL'; // angular display
    let mode='CF';

    const S={ round:0, score:0, high:0, revealed:false, hint:false,
      avgAbs:0, n:0,
      range:200, wind:10, from:120,
      mphGun:6.0,
      trueV:0, trueH:0,
      guessV:0, guessH:0,
      // mapping (computed each draw)
      upxX:0.02, upxY:0.02, // units per pixel
      drag:null, hintBand:null };

    // ===== Helpers =====
    const toMOA=m=>m*MOA_PER_MIL, toMIL=a=>a/MOA_PER_MIL;
    const snap = v => { const step=(units==='MIL')?0.1:0.25; return Math.round(v/step)*step; };
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

    function tryDopeMil(r){ if(r<=RANGES[0])return DOPE_MIL[0]; if(r>=RANGES[RANGES.length-1])return DOPE_MIL[DOPE_MIL.length-1]; for(let i=0;i<RANGES.length-1;i++){const a=RANGES[i],b=RANGES[i+1]; if(r>=a&&r<=b){const t=(r-a)/(b-a); return DOPE_MIL[i]+t*(DOPE_MIL[i+1]-DOPE_MIL[i]);}} return DOPE_MIL[0]; }
    function mphFromRF(fps){ const T=[[900,1.0],[980,1.2],[1040,1.4],[1100,1.7],[1200,2.1],[1300,2.5],[1500,3.0]]; if(fps<=T[0][0])return T[0][1]; if(fps>=T[T.length-1][0])return T[T.length-1][1]; for(let i=0;i<T.length-1;i++){const[x0,y0]=T[i],[x1,y1]=T[i+1]; if(fps>=x0&&fps<=x1){const t=(fps-x0)/(x1-x0); return Math.round((y0+t*(y1-y0))*100)/100;}} return 2.0; }
    function resolveMphGun(){ return (mode==='RF')? mphFromRF(1080) : 6.0; }
    function windHoldMil(rYd, mph, fromDeg){ const rangeKyd=rYd/1000; const s=Math.abs(Math.sin((fromDeg%360)*Math.PI/180)); const sign=((fromDeg%360)<180)?1:-1; return (mph/ (S.mphGun>0?S.mphGun:6.0)) * rangeKyd * s * sign; }

    function inchesToMilAtRange(inches, yd){ const milsPerInch = 1000/(yd*36); return inches*milsPerInch; }

    // ===== UI nodes =====
    const $=id=>document.getElementById(id);
    const HUD={ wind:$('wind'), from:$('from'), range:$('range'), tryV:$('tryV'), avg:$('avg'), unitsAvg:$('unitsAvg'), shotIdx:$('shotIdx'), score:$('score'), high:$('high'), unitsLabel:$('unitsLabel'), modeLabel:$('modeLabel'), round:$('round') };
    const BTN={ hint:$('hint'), reveal:$('reveal'), toggleUnits:$('toggleUnits'), toggleMode:$('toggleMode'), newRound:$('newRound') };

    // ===== Canvas =====
    const canvas=document.getElementById('scope'); const ctx=canvas.getContext('2d',{alpha:true});

    function resize(){ const r=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); draw(); }
    window.addEventListener('resize', resize);

    // ===== Rounds =====
    function pickRange(isRF){ const min=isRF?100:100, max=isRF?400:1000; const steps=Math.floor((max-min)/50); return min + Math.floor(Math.random()*(steps+1))*50; }
    function newRound(){ S.round=(S.round%10)+1; S.revealed=false; S.hint=false; S.hintBand=null; const isRF=(mode==='RF'); S.range=pickRange(isRF); S.wind = 2 + Math.floor(Math.random()*19); const bands=[[60,120],[240,300],[0,360]]; const b=(Math.random()<0.7)?bands[Math.floor(Math.random()*2)]:bands[2]; S.from=Math.random()*(b[1]-b[0])+b[0]; S.mphGun=resolveMphGun(); const eMil=tryDopeMil(S.range); S.trueV=(units==='MIL')?eMil:toMOA(eMil); const wMil=windHoldMil(S.range,S.wind,S.from); S.trueH=(units==='MIL')?wMil:toMOA(wMil); S.guessH=0; S.guessV=S.trueV; updateHUD(); draw(); }

    function reveal(){ if(S.revealed) return; S.revealed=true; const hMil=(units==='MIL')?S.guessH:toMIL(S.guessH); const vMil=(units==='MIL')?S.guessV:toMIL(S.guessV); const tH=(units==='MIL')?S.trueH:toMIL(S.trueH); const tV=(units==='MIL')?S.trueV:toMIL(S.trueV); const dx=hMil-tH, dy=vMil-tV; const zone=scoreZone(dx,dy,S.range); let pts=(zone==='A'?100:zone==='C'?70:zone==='D'?40:0); if(S.hint) pts = Math.floor(pts/2); S.score+=pts; S.high=Math.max(S.high,S.score); S.avgAbs+=Math.abs(hMil); S.n++; updateHUD(); draw(); }
    function hint(){ if(S.revealed) return; S.hint=true; const halfMil=0.2; const half=(units==='MIL')?halfMil:toMOA(halfMil); S.hintBand={min:S.trueH-half, max:S.trueH+half}; draw(); }

    // ===== Mapping (exact to painter) =====
    function mapUnits(center){ const maxHX = (units==='MIL')? MAX_H_MIL : MAX_H_MIL*MOA_PER_MIL; const maxVY = (units==='MIL')? MAX_V_MIL : MAX_V_MIL*MOA_PER_MIL; const usableW = canvas.clientWidth - MARGIN_PX*2; const usableH = canvas.clientHeight - MARGIN_PX*2; const pxPerUnitX = usableW/(maxHX*2.0); const pxPerUnitY = usableH/(maxVY + MAP_CUSHION_UNITS); S.upxX = 1/pxPerUnitX; S.upxY = 1/pxPerUnitY; return {pxPerUnitX, pxPerUnitY, maxHX, maxVY}; }

    // ===== Scoring =====
    function scoreZone(dxMil, dyMil, yd){ const pad=JITTER_MIL; const halfW=inchesToMilAtRange(IPSC.W/2,yd)+pad; const halfH=inchesToMilAtRange(IPSC.H/2,yd)+pad; const torsoTopOffsetMil=inchesToMilAtRange(IPSC.W*0.40,yd); const torsoCenterYMil=torsoTopOffsetMil - halfH + pad; const lx=dxMil; const ly=dyMil - torsoCenterYMil; const inTorso=(Math.abs(lx)<=halfW && Math.abs(ly)<=halfH); if(!inTorso) return 'MISS'; const aHalfW=inchesToMilAtRange(IPSC.A_W/2,yd)+pad*0.6; const aHalfH=inchesToMilAtRange(IPSC.A_H/2,yd)+pad*0.6; const aTopFromTorsoTop=inchesToMilAtRange(IPSC.A_TOP,yd); const aCenterY=(halfH - pad - aTopFromTorsoTop - aHalfH); if(Math.abs(lx)<=aHalfW && Math.abs(ly-aCenterY)<=aHalfH) return 'A'; const dInset=inchesToMilAtRange(IPSC.D,yd)-pad*0.5; const nearEdge=(lx<-halfW+dInset)||(lx>halfW-dInset)||(ly>halfH-dInset)||(ly<-halfH+dInset); if(nearEdge) return 'D'; return 'C'; }

    // ===== Pointer (reticle moves; +V is UP) =====
    function down(e){ const r=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top; S.drag={x,y,h:S.guessH,v:S.guessV}; }
    function move(e){ if(!S.drag) return; const r=canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top; const dx=(x-S.drag.x)*S.upxX; const dy=(y-S.drag.y)*S.upxY; // +dy pixels => +V units DOWN; app defines +V as UP, so negate when applying
      const maxHX=(units==='MIL')? MAX_H_MIL : MAX_H_MIL*MOA_PER_MIL; const maxVY=(units==='MIL')? MAX_V_MIL : MAX_V_MIL*MOA_PER_MIL; S.guessH=clamp(snap(S.drag.h+dx), -maxHX, maxHX); S.guessV=clamp(snap(S.drag.v - dy), 0, maxVY); HUD.tryV.textContent=S.guessV.toFixed(1)+' '+units; draw(); }
    function up(){ if(!S.drag) return; S.guessH=snap(S.guessH); S.guessV=snap(S.guessV); S.drag=null; draw(); }
    canvas.addEventListener('mousedown',down); canvas.addEventListener('mousemove',move); window.addEventListener('mouseup',up); canvas.addEventListener('touchstart',down,{passive:true}); canvas.addEventListener('touchmove',move,{passive:true}); canvas.addEventListener('touchend',up,{passive:true});

    // ===== Drawing =====
    function draw(){ const w=canvas.clientWidth, h=canvas.clientHeight; ctx.clearRect(0,0,w,h); const cx=w/2, cy=h/2; const radius=Math.min(w,h)/2; // compute mapping once
      const {pxPerUnitX, pxPerUnitY, maxHX, maxVY} = mapUnits({x:cx,y:cy});
      // bezel + wind ring
      drawWindRing(cx,cy,radius);
      // silhouette first
      drawIPSC(cx,cy,radius,pxPerUnitX,pxPerUnitY);
      // wind FROM arrow (on ring)
      drawWindArrow(cx,cy,radius);
      // reticle translated by guess (note +V is UP => subtract)
      const offX = S.guessH*pxPerUnitX;
      const offY = -(S.guessV)*pxPerUnitY; 
      ctx.save(); ctx.translate(offX, offY); drawReticle(cx,cy,pxPerUnitX,pxPerUnitY,maxHX,maxVY); ctx.restore();
      // ghost
      if(S.drag){ ctx.fillStyle='rgba(255,255,255,0.65)'; ctx.beginPath(); ctx.arc(cx+offX, cy+offY, 2.5, 0, Math.PI*2); ctx.fill(); }
      // reveal markers and dashed trace
      if(S.revealed){ const th=S.trueH*pxPerUnitX, tv=-(S.trueV)*pxPerUnitY; // convert to pixels
        const gh=offX, gv=offY; // your reticle center after translation
        // dashed line between
        ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(cx+gh, cy+gv); ctx.lineTo(cx+th, cy+tv); ctx.stroke(); ctx.setLineDash([]);
        dot(cx+th, cy+tv, 4, '#4cd137'); dot(cx+gh, cy+gv, 4, '#ffcc00');
      } else { // hint band
        if(S.hintBand){ const x1=cx + S.hintBand.min*pxPerUnitX; const x2=cx + S.hintBand.max*pxPerUnitX; ctx.fillStyle='#8ef5b133'; ctx.fillRect(Math.min(x1,x2), cy-radius, Math.abs(x2-x1), radius*2); }
        dot(cx+offX, cy+offY, 4, '#8ef5b1');
      }
      // ladder rows under disk
      drawLadder(cx, cy + radius + 26, w*0.86, pxPerUnitX);
    }

    function dot(x,y,r,c){ ctx.fillStyle=c; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    // === Bezel & wind ring (15¬∞ ticks, numerals every 30¬∞, HALF/FULL tags) ===
    function drawWindRing(cx,cy,r){ const ring='rgba(255,255,255,0.55)', nums='rgba(255,255,255,0.85)'; ctx.strokeStyle=ring; ctx.lineWidth=1.4; ctx.beginPath(); ctx.arc(cx,cy,r-4,0,Math.PI*2); ctx.stroke(); for(let deg=0;deg<360;deg+=15){ const a=((deg-90)*Math.PI/180); const isLong=(deg%30===0); const r1=r-4-(isLong?10:6), r2=r-4; ctx.strokeStyle=ring; ctx.lineWidth=isLong?1.4:1; ctx.beginPath(); ctx.moveTo(cx+Math.cos(a)*r1, cy+Math.sin(a)*r1); ctx.lineTo(cx+Math.cos(a)*r2, cy+Math.sin(a)*r2); ctx.stroke(); if(deg%30===0){ const label = (deg===30||deg===150||deg===210||deg===330)?'HALF':String(deg); ctx.fillStyle=nums; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='12px ui-monospace, monospace'; const lx=cx+Math.cos(a)*(r-24), ly=cy+Math.sin(a)*(r-24); ctx.fillText(label,lx,ly);} } }

    function drawWindArrow(cx,cy,r){ const deg=S.from; const a = ((deg-90)*Math.PI/180); const baseR = r*0.62, tipR=r*0.9; const baseX=cx+Math.cos(a)*baseR, baseY=cy+Math.sin(a)*baseR; const tipX=cx+Math.cos(a)*tipR, tipY=cy+Math.sin(a)*tipR; // shaft
      const baseColor='rgba(142,245,177,0.9)'; ctx.strokeStyle=baseColor; ctx.lineWidth=2.2; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(baseX,baseY); ctx.lineTo(tipX,tipY); ctx.stroke(); // little taper
      ctx.strokeStyle='rgba(142,245,177,0.85)'; ctx.lineWidth=1.4; ctx.beginPath(); const taperX=cx+Math.cos(a)*((baseR+tipR)/2), taperY=cy+Math.sin(a)*((baseR+tipR)/2); ctx.moveTo(baseX,baseY); ctx.lineTo(taperX,taperY); ctx.stroke(); // head
      const inward=a+Math.PI; const headLen=10; const leftX=tipX+Math.cos(inward+0.45)*headLen, leftY=tipY+Math.sin(inward+0.45)*headLen; const rightX=tipX+Math.cos(inward-0.45)*headLen, rightY=tipY+Math.sin(inward-0.45)*headLen; ctx.fillStyle='rgba(142,245,177,0.35)'; ctx.strokeStyle='rgba(142,245,177,0.9)'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(tipX,tipY); ctx.lineTo(leftX,leftY); ctx.lineTo(rightX,rightY); ctx.closePath(); ctx.fill(); ctx.stroke(); // FROM tag
      ctx.fillStyle='rgba(165,173,189,0.95)'; ctx.font='12px ui-monospace, monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; const tagX=cx+Math.cos(a)* (tipR+18), tagY=cy+Math.sin(a)*(tipR+18); ctx.fillText('FROM', tagX, tagY); }

    // === IPSC with gradient head + torso aligned to waterline ===
    function drawIPSC(cx,cy,r,pxX,pxY){ const halfW=inchesToMilAtRange(IPSC.W/2,S.range)*pxX; const halfH=inchesToMilAtRange(IPSC.H/2,S.range)*pxY; const topOff=inchesToMilAtRange(IPSC.W*0.40,S.range)*pxY; const torsoCy=cy + (topOff - halfH) + JITTER_MIL*pxY; // body
      const x=cx-halfW, y=torsoCy-halfH, w=halfW*2, h=halfH*2; // shadow-like fill
      // gradient body
      const grad=ctx.createLinearGradient(0,y,0,y+h); grad.addColorStop(0,'#343946'); grad.addColorStop(1,'#1C2029'); ctx.save(); ctx.beginPath(); ctx.rect(x,y,w,h); ctx.fillStyle=grad; ctx.fill(); ctx.strokeStyle='rgba(255,255,255,0.22)'; ctx.lineWidth=1; ctx.stroke(); ctx.restore(); // head
      const headW = halfW*0.55, headH = halfH*0.28; const headY = y - headH*0.62; ctx.fillStyle='rgba(52,57,70,0.9)'; ctx.fillRect(cx-headW, headY, headW*2, headH); ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.strokeRect(cx-headW, headY, headW*2, headH); // A zone
      const aHalfW=inchesToMilAtRange(IPSC.A_W/2,S.range)*pxX + JITTER_MIL*0.6*pxX; const aHalfH=inchesToMilAtRange(IPSC.A_H/2,S.range)*pxY + JITTER_MIL*0.6*pxY; const aTop=torsoCy - halfH + inchesToMilAtRange(IPSC.A_TOP,S.range)*pxY; const aCy=aTop + aHalfH; ctx.strokeStyle='rgba(255,255,255,0.42)'; ctx.strokeRect(cx-aHalfW, aCy-aHalfH, aHalfW*2, aHalfH*2); }

    // === Reticle tree (center line + rows, MOA/MIL styles) ===
    function drawReticle(cx,cy,pxX,pxY,maxHX,maxVY){ const isMOA=(units==='MOA'); const eps=1e-6; const majorStep=isMOA?2:1; const minorStep=isMOA?1:0.5; const centerQuiet = isMOA ? 2.0 : 0.0; // waterline and center cross
      ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1.2; ctx.beginPath(); ctx.moveTo(cx - maxHX*pxX, cy); ctx.lineTo(cx + maxHX*pxX, cy); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - maxVY*pxY); ctx.stroke(); // center tiny cross
      ctx.beginPath(); ctx.moveTo(cx-8,cy); ctx.lineTo(cx+8,cy); ctx.moveTo(cx,cy-8); ctx.lineTo(cx,cy+8); ctx.stroke();
      // ticks along center (horizontal scale)
      for(let u=-maxHX; u<=maxHX+eps; u+=minorStep){ const absu=Math.abs(u); if(isMOA && absu<=centerQuiet+eps && Math.abs(absu/2 - Math.round(absu/2))>eps) continue; const x = cx + u*pxX; let len, color='rgba(255,255,255,0.75)', lw=1; if(isMOA){ const is10 = Math.abs(u/10 - Math.round(u/10))<eps; const is5 = Math.abs(u/5 - Math.round(u/5))<eps; const is2 = Math.abs(u/2 - Math.round(u/2))<eps; if(is10){ len=16; lw=1.2; color='rgba(255,255,255,0.85)'; } else if(is5){ len=13; lw=1.2; color='rgba(255,255,255,0.8)'; } else if(is2){ len=10; } else if (absu<eps){ len=12; lw=1.2; color='rgba(255,255,255,0.85)'; } else { len=7; color='rgba(255,255,255,0.6)'; } } else { const isMajor = Math.abs(u - Math.round(u))<eps; len = isMajor?12:6; lw=isMajor?1.2:1; color=isMajor?'rgba(255,255,255,0.85)':'rgba(255,255,255,0.6)'; }
        ctx.strokeStyle=color; ctx.lineWidth=lw; ctx.beginPath(); ctx.moveTo(x, cy-len/2); ctx.lineTo(x, cy+len/2); ctx.stroke(); if((isMOA && Math.abs(u/10 - Math.round(u/10))<eps) || (!isMOA && Math.abs(u - Math.round(u))<eps)) { ctx.fillStyle='rgba(165,173,189,0.95)'; ctx.font='12px ui-monospace, monospace'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText((isMOA?u:Math.round(u)).toString(), x, cy-12); } }
      // rows with chevrons
      const chevEvery = isMOA?10:2; for(let v=majorStep; v<=maxVY; v+=majorStep){ ctx.strokeStyle='rgba(255,255,255,0.45)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(cx - maxHX*pxX, cy - v*pxY); ctx.lineTo(cx + maxHX*pxX, cy - v*pxY); ctx.stroke(); if((v%chevEvery)===0){ // chevron pointing up to center
          ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=1.4; ctx.beginPath(); ctx.moveTo(cx-10, cy - v*pxY + 10); ctx.lineTo(cx, cy - v*pxY); ctx.lineTo(cx+10, cy - v*pxY + 10); ctx.stroke(); ctx.fillStyle='rgba(165,173,189,0.95)'; ctx.font='12px ui-monospace, monospace'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(String(v), cx - maxHX*pxX + 12, cy - v*pxY - 10); } }
    }

    // ladder rows below disk (visual)
    function drawLadder(cx, topY, width, pxX){ const isMOA=(units==='MOA'); const majorStep=isMOA?2:1; const left=cx-width/2, right=cx+width/2; let y=topY; for(let v=2; v<=12; v+=majorStep){ ctx.strokeStyle='rgba(255,255,255,0.21)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke(); const minorStep=isMOA?1:0.5; for(let i=1;i<Math.floor((right-left)/(pxX*minorStep));i++){ const x=left + i*pxX*minorStep; ctx.beginPath(); ctx.moveTo(x,y-4); ctx.lineTo(x,y+4); ctx.stroke(); } ctx.fillStyle='rgba(165,173,189,0.95)'; ctx.textAlign='right'; ctx.textBaseline='middle'; ctx.font='12px ui-monospace, monospace'; ctx.fillText(String(v), left-12, y); y+=24; } }

    // ===== HUD =====
    function updateHUD(){ HUD.wind.textContent=S.wind.toFixed(0); HUD.from.textContent=S.from.toFixed(0); HUD.range.textContent=S.range.toFixed(0); HUD.tryV.textContent=S.guessV.toFixed(1)+' '+units; HUD.avg.textContent=(S.n? (S.avgAbs/S.n):0).toFixed(1); HUD.unitsAvg.textContent=units; HUD.shotIdx.textContent=S.round.toString(); HUD.score.textContent=S.score.toString(); HUD.high.textContent=S.high.toString(); HUD.unitsLabel.textContent=units; HUD.modeLabel.textContent=(mode==='CF'?'Centerfire':'Rimfire'); HUD.round.textContent=S.round.toString(); }

    // ===== Buttons =====
    BTN.reveal.onclick=reveal; BTN.hint.onclick=hint; BTN.toggleUnits.onclick=()=>{ const conv=(units==='MIL')?toMOA:toMIL; S.guessH=conv(S.guessH); S.guessV=conv(S.guessV); S.trueH=conv(S.trueH); S.trueV=conv(S.trueV); units=(units==='MIL')?'MOA':'MIL'; updateHUD(); draw(); }; BTN.toggleMode.onclick=()=>{ mode=(mode==='CF')?'RF':'CF'; newRound(); }; BTN.newRound.onclick=()=>{ S.round=0; S.score=0; S.avgAbs=0; S.n=0; newRound(); };

    // ===== Boot =====
    function boot(){ const r=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1; canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr); ctx.setTransform(dpr,0,0,dpr,0,0); newRound(); }
    boot();
  })();
  </script>
</body>
</html>
