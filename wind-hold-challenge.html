<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cross-Wind Hold Trainer — 1:1 Web Replica</title>
<style>
  :root{--bg:#0e1116;--ink:#e7e9ef;--muted:#a5adbd;--accent:#8ef5b1;--line:#1e2536}
  *{box-sizing:border-box}
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:grid;grid-template-rows:min-content 1fr min-content;height:100%}
  .hud{display:grid;grid-auto-flow:column;gap:10px;padding:12px;align-items:center}
  .pill{background:#0f1422;border:1px solid var(--line);border-radius:12px;padding:10px 12px;white-space:nowrap}
  .stage{position:relative;width:100%;height:calc(100vh - 170px);min-height:560px}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  .footer{display:grid;grid-template-columns:1fr auto auto;gap:12px;padding:12px;align-items:center}
  .btn{cursor:pointer;background:#0c1520;border:1px solid var(--line);color:var(--ink);padding:12px 14px;border-radius:14px;font-weight:700}
  .btn.primary{background:#0f1c16;border-color:#214636;color:var(--accent)}
  .btn.warn{background:#1d1414;border-color:#3b2323;color:#ff8a8a}
  @media (max-width:900px){
    .stage{height:calc(100vh - 220px)}
    .hud{grid-auto-flow:row;grid-template-columns:repeat(2,minmax(0,1fr))}
    .footer{grid-template-columns:1fr}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="pill">💨 <strong>Wind:</strong> <span id="wind">—</span> mph FROM <span id="from">—</span>°</div>
    <div class="pill">📏 <strong>Range:</strong> <span id="range">—</span> yds</div>
    <div class="pill">⬇️ <strong>Try DOPE:</strong> <span id="tryV">—</span></div>
    <div class="pill">📈 <strong>Avg:</strong> <span id="avg">0.0</span> <span id="unitsAvg">MIL</span> (<span id="shotIdx">0</span>/10)</div>
    <div class="pill">🎯 <strong>Score:</strong> <span id="score">0</span> • High: <span id="high">0</span></div>
    <div class="pill">⚙️ <strong><span id="unitsLabel">MIL</span></strong> • <span id="modeLabel">Centerfire</span></div>
  </div>

  <div class="stage"><canvas id="scope"></canvas></div>

  <div class="footer">
    <div style="font-weight:800">Round <span id="round">0</span>/10</div>
    <div style="display:flex;gap:10px">
      <button id="hint" class="btn">💡 Hint (−50%)</button>
      <button id="reveal" class="btn primary">👁️ Reveal</button>
    </div>
    <div style="display:flex;gap:10px">
      <button id="toggleUnits" class="btn">Toggle MIL/MOA</button>
      <button id="toggleMode" class="btn">Centerfire/Rimfire</button>
      <button id="newRound" class="btn warn">New Session</button>
    </div>
  </div>
</div>

<script>
(()=>{
  const MOA_PER_MIL=3.43774677;
  const MAX_H_MIL=6.0, MAX_V_MIL=12.0;
  const MARGIN_PX=12.0, MAP_CUSHION_UNITS=0.5;
  const JITTER_MIL=0.12;

  const RANGES=[100,200,300,400,500,600,700,800,900,1000];
  const DOPE_MIL=[0.0,0.5,1.1,1.9,3.0,4.2,5.6,7.1,8.8,10.6];
  const IPSC={W:18,H:30,A_W:6,A_H:11,A_TOP:4,D:3};

  let units='MIL', mode='CF';

  const S={
    round:0, score:0, high:+(localStorage.getItem('xwind_high')||0),
    revealed:false, hint:false, hintBand:null,
    sumAbs:0, n:0,
    range:200, wind:10, from:120,
    mphGun:6.0,
    trueV:0,trueH:0,
    guessV:0,guessH:0,
    upxX:0.02,upxY:0.02,
    drag:null
  };

  const $=id=>document.getElementById(id);
  const HUD={wind:$('wind'),from:$('from'),range:$('range'),tryV:$('tryV'),avg:$('avg'),unitsAvg:$('unitsAvg'),
             shotIdx:$('shotIdx'),score:$('score'),high:$('high'),unitsLabel:$('unitsLabel'),
             modeLabel:$('modeLabel'),round:$('round')};
  const BTN={hint:$('hint'),reveal:$('reveal'),toggleUnits:$('toggleUnits'),toggleMode:$('toggleMode'),newRound:$('newRound')};

  const canvas=$('scope'); const ctx=canvas.getContext('2d',{alpha:true});

  const toMOA=m=>m*MOA_PER_MIL, toMIL=a=>a/MOA_PER_MIL;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const snap=v=>(units==='MIL'?Math.round(v*10)/10:Math.round(v*4)/4);

  function tryDopeMil(r){
    if(r<=RANGES[0])return DOPE_MIL[0];
    if(r>=RANGES.at(-1))return DOPE_MIL.at(-1);
    for(let i=0;i<RANGES.length-1;i++){
      const a=RANGES[i],b=RANGES[i+1];
      if(r>=a&&r<=b){const t=(r-a)/(b-a);return DOPE_MIL[i]+t*(DOPE_MIL[i+1]-DOPE_MIL[i]);}
    }
    return DOPE_MIL[0];
  }
  function mphFromRF(fps){
    const T=[[900,1.0],[980,1.2],[1040,1.4],[1100,1.7],[1200,2.1],[1300,2.5],[1500,3.0]];
    if(fps<=T[0][0])return T[0][1]; if(fps>=T.at(-1)[0])return T.at(-1)[1];
    for(let i=0;i<T.length-1;i++){const[x0,y0]=T[i],[x1,y1]=T[i+1]; if(fps>=x0&&fps<=x1){const t=(fps-x0)/(x1-x0); return Math.round((y0+t*(y1-y0))*100)/100;}}
    return 2.0;
  }
  function resolveMphGun(){return (mode==='RF')?mphFromRF(1080):6.0;}
  function windHoldMil(rYd,mph,fromDeg){
    const rangeKyd=rYd/1000;
    const s=Math.abs(Math.sin((fromDeg%360)*Math.PI/180));
    const sign=((fromDeg%360)<180)?1:-1;
    return (mph/(S.mphGun||6))*rangeKyd*s*sign;
  }
  function inchesToMilAtRange(inches,yd){return inches*(1000/(yd*36));}

  function resize(){
    const r=canvas.getBoundingClientRect(); const dpr=window.devicePixelRatio||1;
    canvas.width=Math.floor(r.width*dpr); canvas.height=Math.floor(r.height*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0); draw();
  }
  window.addEventListener('resize',resize);

  function pickRange(isRF){const min=isRF?100:100,max=isRF?400:1000;const steps=Math.floor((max-min)/50);return min+Math.floor(Math.random()*(steps+1))*50;}

  function newRound(){
    S.round=(S.round%10)+1; S.revealed=false; S.hint=false; S.hintBand=null;
    const isRF=(mode==='RF'); S.range=pickRange(isRF); S.wind=2+Math.floor(Math.random()*19);
    const bands=[[60,120],[240,300],[0,360]]; const b=(Math.random()<0.7)?bands[Math.floor(Math.random()*2)]:bands[2];
    S.from=Math.random()*(b[1]-b[0])+b[0];
    S.mphGun=resolveMphGun();
    const eMil=tryDopeMil(S.range); S.trueV=(units==='MIL')?eMil:toMOA(eMil);
    const wMil=windHoldMil(S.range,S.wind,S.from); S.trueH=(units==='MIL')?wMil:toMOA(wMil);
    S.guessH=0; S.guessV=S.trueV; // start at suggested elevation
    updateHUD(); draw();
  }

  function reveal(){
    if(S.revealed)return; S.revealed=true;
    const hMil=(units==='MIL')?S.guessH:toMIL(S.guessH);
    const vMil=(units==='MIL')?S.guessV:toMIL(S.guessV);
    const tH =(units==='MIL')?S.trueH:toMIL(S.trueH);
    const tV =(units==='MIL')?S.trueV:toMIL(S.trueV);
    const dx=hMil-tH, dy=vMil-tV;

    const zone=scoreZone(dx,dy,S.range);
    let pts=(zone==='A'?100:zone==='C'?70:zone==='D'?40:0); if(S.hint) pts=Math.floor(pts/2);
    S.score+=pts; S.high=Math.max(S.high,S.score); localStorage.setItem('xwind_high',String(S.high));
    S.sumAbs+=Math.hypot(dx,dy); S.n++; updateHUD(); draw();
  }
  function hint(){ if(S.revealed) return; S.hint=true; const halfMil=0.2; const half=(units==='MIL')?halfMil:toMOA(halfMil); S.hintBand={min:S.trueH-half,max:S.trueH+half}; draw(); }

  function mapUnits(w,h){
    const maxHX=(units==='MIL')?MAX_H_MIL:MAX_H_MIL*MOA_PER_MIL;
    const maxVY=(units==='MIL')?MAX_V_MIL:MAX_V_MIL*MOA_PER_MIL;
    const usableW=w-MARGIN_PX*2, usableH=h-MARGIN_PX*2;
    const pxPerUnitX=usableW/(maxHX*2.0);
    const pxPerUnitY=usableH/(maxVY+MAP_CUSHION_UNITS);
    S.upxX=1/pxPerUnitX; S.upxY=1/pxPerUnitY;
    return {pxPerUnitX,pxPerUnitY,maxHX,maxVY};
  }

  function scoreZone(dxMil,dyMil,yd){
    const pad=JITTER_MIL;
    const halfW=inchesToMilAtRange(IPSC.W/2,yd)+pad;
    const halfH=inchesToMilAtRange(IPSC.H/2,yd)+pad;
    const torsoTopOffsetMil=inchesToMilAtRange(IPSC.W*0.40,yd);
    const torsoCenterYMil=torsoTopOffsetMil - halfH + pad;
    const lx=dxMil;
    const ly=dyMil - torsoCenterYMil;
    const inTorso=(Math.abs(lx)<=halfW && Math.abs(ly)<=halfH);
    if(!inTorso) return 'MISS';
    const aHalfW=inchesToMilAtRange(IPSC.A_W/2,yd)+pad*0.6;
    const aHalfH=inchesToMilAtRange(IPSC.A_H/2,yd)+pad*0.6;
    const aTopFromTorsoTop=inchesToMilAtRange(IPSC.A_TOP,yd);
    const aCenterY=(halfH - pad - aTopFromTorsoTop - aHalfH);
    if(Math.abs(lx)<=aHalfW && Math.abs(ly-aCenterY)<=aHalfH) return 'A';
    const dInset=inchesToMilAtRange(IPSC.D,yd)-pad*0.5;
    const nearEdge=(lx<-halfW+dInset)||(lx>halfW-dInset)||(ly>halfH-dInset)||(ly<-halfH+dInset);
    if(nearEdge) return 'D';
    return 'C';
  }

  function draw(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    const cx=w/2, cy=h/2;
    const radius=Math.min(w,h)/2;
    ctx.fillStyle='#0f1116'; ctx.beginPath(); ctx.arc(cx,cy,radius,0,Math.PI*2); ctx.fill();

    const {pxPerUnitX,pxPerUnitY,maxHX,maxVY}=mapUnits(w,h);

    // --- Correct holdover translation ---
    // Move the *reticle tree* DOWN by +guessV so that the "guessV" row sits on the center line.
    const offX = S.guessH*pxPerUnitX;
    const offY = +(S.guessV)*pxPerUnitY;   // <-- fixed sign (was negative)

    // Clip to scope
    ctx.save();
    ctx.beginPath(); ctx.arc(cx,cy,radius-2,0,Math.PI*2); ctx.clip();
    ctx.fillStyle='#0b0e15'; ctx.fillRect(0,0,w,h);

    // Compute A-zone anchor from truth (target stays put)
    const anchorX = cx + (S.trueH*pxPerUnitX);
    const anchorY = cy - (S.trueV*pxPerUnitY);

    // Draw silhouette so that A-zone center == truth anchor
    drawIPSCAnchored(anchorX, anchorY, pxPerUnitX, pxPerUnitY);

    // Reticle (on top), translated so the chosen hash is at center
    ctx.save(); ctx.translate(offX,offY);
    drawReticle(cx,cy,pxPerUnitX,pxPerUnitY,maxHX,maxVY);
    ctx.restore();

    // Wind arrow bezel marker
    drawWindArrow(cx,cy,radius);

    // --- Correct "your hold" aim point ---
    // When you hold v MIL, the *aim point* is the center line after translating the tree.
    // So plot your yellow dot at (cx + guessH, cy), not at the reticle center.
    if(S.revealed){
      const th = S.trueH*pxPerUnitX;
      const tv = -S.trueV*pxPerUnitY;
      const gh = offX;
      const gy = 0; // center line is the aim row
      ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(255,255,255,0.65)'; ctx.lineWidth=1.4;
      ctx.beginPath(); ctx.moveTo(cx+gh,cy+gy); ctx.lineTo(cx+th,cy+tv); ctx.stroke(); ctx.setLineDash([]);
      dot(cx+th,cy+tv,4,'#4cd137'); // truth
      dot(cx+gh,cy+gy,4,'#ffcc00'); // your aim
    } else {
      if(S.hintBand){
        const x1=cx + S.hintBand.min*pxPerUnitX; const x2=cx + S.hintBand.max*pxPerUnitX;
        ctx.fillStyle='#8ef5b155'; ctx.fillRect(Math.min(x1,x2), cy-radius, Math.abs(x2-x1), radius*2);
      }
      dot(cx+offX, cy, 4, '#8ef5b1'); // show your aim at center line
    }

    ctx.restore();

    // Bezel & ladder
    drawWindRing(cx,cy,radius);
    drawLadder(cx, cy + radius + 26, w*0.86, pxPerUnitX);
  }

  function dot(x,y,r,c){ctx.fillStyle=c;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();}

  function drawWindRing(cx,cy,r){
    const ring='rgba(255,255,255,0.55)', nums='rgba(255,255,255,0.9)';
    ctx.strokeStyle=ring; ctx.lineWidth=1.4;
    ctx.beginPath(); ctx.arc(cx,cy,r-4,0,Math.PI*2); ctx.stroke();
    for(let deg=0;deg<360;deg+=15){
      const a=((deg-90)*Math.PI/180), long=(deg%30===0);
      const r1=r-4-(long?10:6), r2=r-4;
      ctx.strokeStyle=ring; ctx.lineWidth=long?1.4:1;
      ctx.beginPath(); ctx.moveTo(cx+Math.cos(a)*r1,cy+Math.sin(a)*r1);
      ctx.lineTo(cx+Math.cos(a)*r2,cy+Math.sin(a)*r2); ctx.stroke();
      if(long){
        const label=(deg===30||deg===150||deg===210||deg===330)?'HALF':String(deg);
        ctx.fillStyle=nums; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='12px ui-monospace,monospace';
        const lx=cx+Math.cos(a)*(r-24), ly=cy+Math.sin(a)*(r-24); ctx.fillText(label,lx,ly);
      }
    }
  }

  function drawWindArrow(cx,cy,r){
    const deg=S.from, a=((deg-90)*Math.PI/180), baseR=r*0.62, tipR=r*0.9;
    const baseX=cx+Math.cos(a)*baseR, baseY=cy+Math.sin(a)*baseR;
    const tipX=cx+Math.cos(a)*tipR, tipY=cy+Math.sin(a)*tipR;
    ctx.strokeStyle='rgba(142,245,177,0.9)'; ctx.lineWidth=2.2; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(baseX,baseY); ctx.lineTo(tipX,tipY); ctx.stroke();
    const inward=a+Math.PI, head=10;
    const lx=tipX+Math.cos(inward+0.45)*head, ly=tipY+Math.sin(inward+0.45)*head;
    const rx=tipX+Math.cos(inward-0.45)*head, ry=tipY+Math.sin(inward-0.45)*head;
    ctx.fillStyle='rgba(142,245,177,0.35)'; ctx.strokeStyle='rgba(142,245,177,0.9)'; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(tipX,tipY); ctx.lineTo(lx,ly); ctx.lineTo(rx,ry); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle='rgba(165,173,189,0.95)'; ctx.font='12px ui-monospace,monospace'; ctx.textAlign='center'; ctx.textBaseline='middle';
    const tx=cx+Math.cos(a)*(tipR+18), ty=cy+Math.sin(a)*(tipR+18); ctx.fillText('FROM',tx,ty);
  }

  // Draw torso so that A-zone center == (anchorX, anchorY)
  function drawIPSCAnchored(anchorX, anchorY, pxX, pxY){
    const halfW_mil = inchesToMilAtRange(IPSC.W/2, S.range);
    const halfH_mil = inchesToMilAtRange(IPSC.H/2, S.range);
    const aHalfW_mil = inchesToMilAtRange(IPSC.A_W/2, S.range);
    const aHalfH_mil = inchesToMilAtRange(IPSC.A_H/2, S.range);
    const aTopOffset_mil = inchesToMilAtRange(IPSC.A_TOP, S.range);

    const halfW_px = halfW_mil*pxX;
    const halfH_px = halfH_mil*pxY;
    const aHalfW_px = aHalfW_mil*pxX;
    const aHalfH_px = aHalfH_mil*pxY;
    const aTopOffset_px = aTopOffset_mil*pxY;

    // Solve torso center so A-zone center hits anchor
    const torsoCy = anchorY + halfH_px - aTopOffset_px - aHalfH_px;

    const torsoX = anchorX - halfW_px;
    const torsoY = torsoCy - halfH_px;
    const torsoW = halfW_px*2;
    const torsoH = halfH_px*2;

    // Body
    ctx.fillStyle='#1C2029';
    ctx.strokeStyle='rgba(255,255,255,0.22)'; ctx.lineWidth=1;
    roundRect(torsoX, torsoY, torsoW, torsoH, 8, true, true);

    // Waterline across torso center
    ctx.strokeStyle='rgba(255,255,255,0.28)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(torsoX, torsoCy); ctx.lineTo(torsoX+torsoW, torsoCy); ctx.stroke();

    // A-zone box
    const aCx = anchorX, aCy = anchorY;
    ctx.strokeStyle='rgba(255,255,255,0.45)';
    ctx.strokeRect(aCx - aHalfW_px, aCy - aHalfH_px, aHalfW_px*2, aHalfH_px*2);

    // Head (cleaner)
    const headW = halfW_px*0.55, headH = halfH_px*0.28;
    const headY = torsoY - headH*0.62;
    ctx.fillStyle='rgba(52,57,70,0.9)';
    roundRect(aCx - headW, headY, headW*2, headH, 6, true, false);
    ctx.strokeStyle='rgba(255,255,255,0.25)';
    roundRect(aCx - headW, headY, headW*2, headH, 6, false, true);
  }

  function roundRect(x,y,w,h,r,fill,stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    if(fill) ctx.fill();
    if(stroke) ctx.stroke();
  }

  function drawReticle(cx,cy,pxX,pxY,maxHX,maxVY){
    const isMOA=(units==='MOA'), eps=1e-6;
    const minorStep=isMOA?1:0.5, majorStep=1, rowStep=isMOA?2:1, rowLabelEvery=isMOA?10:1;
    const centerQuiet=isMOA?1.0:0.0;
    function isMult(v,step){const m=Math.abs(v)%step;return m<eps||step-m<eps;}

    // Axes
    ctx.strokeStyle='rgba(255,255,255,0.95)'; ctx.lineWidth=1.8;
    ctx.beginPath(); ctx.moveTo(cx - maxHX*pxX, cy); ctx.lineTo(cx + maxHX*pxX, cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx, cy - maxVY*pxY); ctx.stroke();
    // Center cross
    ctx.beginPath(); ctx.moveTo(cx-8,cy); ctx.lineTo(cx+8,cy); ctx.moveTo(cx,cy-8); ctx.lineTo(cx,cy+8); ctx.stroke();

    // Horizontal ticks
    for(let u=-maxHX; u<=maxHX+eps; u+=minorStep){
      const absu=Math.abs(u); if(isMOA && absu<=centerQuiet+eps && !isMult(absu,majorStep)) continue;
      const x=cx + u*pxX; let len=7; ctx.lineWidth=1.2; ctx.strokeStyle='rgba(255,255,255,0.9)';
      if(isMOA){
        if(isMult(absu,10)){len=16; ctx.lineWidth=2.0;}
        else if(isMult(absu,5)){len=13; ctx.lineWidth=1.6;}
        else if(isMult(absu,2)){len=10;}
      }else{
        if(isMult(absu,1)){len=12; ctx.lineWidth=1.6;} else {len=6;}
      }
      ctx.beginPath(); ctx.moveTo(x, cy-len/2); ctx.lineTo(x, cy+len/2); ctx.stroke();
      const showLabel = isMOA ? isMult(absu,10) : isMult(absu,1);
      if(absu>eps && showLabel){
        ctx.fillStyle='rgba(225,230,240,0.95)'; ctx.font='12px ui-monospace,monospace'; ctx.textAlign='center'; ctx.textBaseline='top';
        ctx.fillText(String(isMOA?absu:Math.round(absu)), x, cy+14);
      }
    }

    // Rows down
    const maxRow=Math.floor(maxVY);
    for(let row=rowStep; row<=maxRow; row+=rowStep){
      const y=cy + row*pxY; const branch=maxHX*(row/maxVY);
      const xL=cx-branch*pxX, xR=cx+branch*pxX;
      ctx.strokeStyle=isMOA?(row%10===0?'rgba(255,255,255,1.0)':row%5===0?'rgba(255,255,255,0.85)':'rgba(255,255,255,0.7)'):'rgba(255,255,255,0.8)';
      ctx.lineWidth=isMOA?(row%10===0?2:row%5===0?1.6:1.2):1.2;
      ctx.beginPath(); ctx.moveTo(xL,y); ctx.lineTo(xR,y); ctx.stroke();

      for(let u=-branch; u<=branch+eps; u+=minorStep){
        const absu=Math.abs(u); if(isMOA && absu<=centerQuiet+eps && !isMult(absu,1.0)) continue;
        const x=cx + u*pxX; let len=isMOA?5:4; ctx.lineWidth=1.0; ctx.strokeStyle='rgba(255,255,255,0.85)';
        if(isMOA){
          if(isMult(absu,10)){len=11; ctx.lineWidth=1.6;}
          else if(isMult(absu,5)){len=9; ctx.lineWidth=1.4;}
          else if(isMult(absu,2)){len=7; ctx.lineWidth=1.2;}
        }else{
          if(isMult(absu,1)){len=8; ctx.lineWidth=1.2;}
        }
        ctx.beginPath(); ctx.moveTo(x,y-len/2); ctx.lineTo(x,y+len/2); ctx.stroke();
      }

      if(row%rowLabelEvery===0){
        ctx.fillStyle='rgba(225,230,240,0.95)'; ctx.font='12px ui-monospace,monospace'; ctx.textAlign='right'; ctx.textBaseline='bottom';
        ctx.fillText(String(row), xL-10, y-6);
      }
    }

    // Unit tag
    ctx.fillStyle='rgba(225,230,240,0.95)'; ctx.font='12px ui-monospace,monospace'; ctx.textAlign='left'; ctx.textBaseline='bottom';
    ctx.fillText(units, cx - (maxHX+0.6)*pxX, cy - 10);
  }

  function drawLadder(cx,topY,width,pxX){
    const isMOA=(units==='MOA'); const major=isMOA?2:1; const left=cx-width/2, right=cx+width/2; let y=topY;
    for(let v=2; v<=12; v+=major){
      ctx.strokeStyle='rgba(255,255,255,0.21)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(left,y); ctx.lineTo(right,y); ctx.stroke();
      const minor=isMOA?1:0.5; const n=Math.floor((right-left)/(pxX*minor));
      for(let i=1;i<n;i++){const x=left+i*pxX*minor; ctx.beginPath(); ctx.moveTo(x,y-4); ctx.lineTo(x,y+4); ctx.stroke();}
      ctx.fillStyle='rgba(225,230,240,0.95)'; ctx.font='12px ui-monospace,monospace'; ctx.textAlign='right'; ctx.textBaseline='middle';
      ctx.fillText(String(v), left-12, y); y+=24;
    }
  }

  function updateHUD(){
    HUD.wind.textContent=S.wind.toFixed(0);
    HUD.from.textContent=S.from.toFixed(0);
    HUD.range.textContent=S.range.toFixed(0);
    HUD.tryV.textContent=S.guessV.toFixed(1)+' '+units;
    HUD.avg.textContent=(S.n?(S.sumAbs/S.n):0).toFixed(1);
    HUD.unitsAvg.textContent=units;
    HUD.shotIdx.textContent=S.round.toString();
    HUD.score.textContent=S.score.toString();
    HUD.high.textContent=S.high.toString();
    HUD.unitsLabel.textContent=units;
    HUD.modeLabel.textContent=(mode==='CF'?'Centerfire':'Rimfire');
    HUD.round.textContent=S.round.toString();
  }

  // Pointer/drag (drag DOWN => more elevation)
  function down(e){const r=canvas.getBoundingClientRect();const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;S.drag={x,y,h:S.guessH,v:S.guessV};}
  function move(e){
    if(!S.drag) return;
    const r=canvas.getBoundingClientRect();
    const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left;
    const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
    const dx=(x-S.drag.x)*S.upxX, dy=(y-S.drag.y)*S.upxY;
    const maxHX=(units==='MIL')?MAX_H_MIL:MAX_H_MIL*MOA_PER_MIL;
    const maxVY=(units==='MIL')?MAX_V_MIL:MAX_V_MIL*MOA_PER_MIL;
    S.guessH=clamp(snap(S.drag.h+dx),-maxHX,maxHX);
    S.guessV=clamp(snap(S.drag.v + dy),0,maxVY);  // <-- fixed (was v - dy)
    HUD.tryV.textContent=S.guessV.toFixed(1)+' '+units;
    draw();
  }
  function up(){if(!S.drag) return; S.guessH=snap(S.guessH); S.guessV=snap(S.guessV); S.drag=null; draw();}

  BTN.reveal.onclick=reveal;
  BTN.hint.onclick=hint;
  BTN.toggleUnits.onclick=()=>{const conv=(units==='MIL')?toMOA:toMIL; S.guessH=conv(S.guessH); S.guessV=conv(S.guessV); S.trueH=conv(S.trueH); S.trueV=conv(S.trueV); units=(units==='MIL')?'MOA':'MIL'; updateHUD(); draw();};
  BTN.toggleMode.onclick=()=>{mode=(mode==='CF')?'RF':'CF'; newRound();};
  BTN.newRound.onclick=()=>{S.round=0;S.score=0;S.sumAbs=0;S.n=0;newRound();};

  function boot(){ resize(); newRound(); }
  boot();
})();
</script>
</body>
</html>
