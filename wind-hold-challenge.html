<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cross‚ÄëWind Challenge</title>
  <style>
    :root {
      --bg: #0e1116;
      --panel: #151925;
      --ink: #e7e9ef;
      --muted: #a5adbd;
      --accent: #8ef5b1;
      --line: #1e2536;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    body { background: var(--bg); color: var(--ink); font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { display: grid; grid-template-rows: min-content 1fr min-content; height: 100%; }

    /* HUD */
    .hud { display: grid; grid-auto-flow: column; gap: 10px; padding: 12px; justify-content: start; }
    .pill { background: #0f1422; border: 1px solid var(--line); border-radius: 12px; padding: 10px 12px; color: var(--ink); box-shadow: inset 0 0 0 1px #00000040; }
    .pill strong { font-weight: 700; opacity: .95; }

    /* Stage */
    .stage { position: relative; width: 100%; height: calc(100vh - 160px); min-height: 520px; }
    canvas { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }

    /* Footer */
    .footer { display: grid; grid-template-columns: 1fr auto auto; gap: 12px; padding: 12px; align-items: center; }
    .score { font-size: 18px; font-weight: 800; letter-spacing: .4px; }
    .btn { cursor: pointer; user-select: none; background: #0c1520; border: 1px solid var(--line); color: var(--ink); padding: 12px 14px; border-radius: 14px; font-weight: 700; }
    .btn:hover { border-color: #2f4162; }
    .btn.primary { background: #0f1c16; border-color: #214636; color: var(--accent); }
    .btn.ghost { background: #0f1422; }
    .btn.warn { background: #1d1414; border-color: #3b2323; color: #ff8a8a; }

    /* mobile tweaks */
    @media (max-width: 900px){
      .stage { height: calc(100vh - 210px); }
      .hud { grid-auto-flow: row; grid-template-columns: repeat(2, minmax(0,1fr)); }
      .footer { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- HUD pills like the app -->
    <div class="hud">
      <div class="pill">üí® <strong>Wind:</strong> <span id="wind">‚Äî</span> mph FROM <span id="from">‚Äî</span>¬∞</div>
      <div class="pill">üìè <strong>Range:</strong> <span id="range">‚Äî</span> yds</div>
      <div class="pill">‚¨áÔ∏è <strong>Try DOPE:</strong> <span id="tryV">‚Äî</span> UP</div>
      <div class="pill">üìà <strong>Avg:</strong> <span id="avg">0.0</span> <span id="unitsAvg">MIL</span> (<span id="shotIdx">0</span>/10)</div>
      <div class="pill">üéØ <strong>Score:</strong> <span id="score">0</span> ‚Ä¢ High: <span id="high">0</span></div>
      <div class="pill">‚öôÔ∏è <strong><span id="unitsLabel">MIL</span></strong> ‚Ä¢ <span id="modeLabel">Centerfire</span></div>
    </div>

    <div class="stage">
      <canvas id="scope"></canvas>
    </div>

    <div class="footer">
      <div class="score">Round <span id="round">0</span>/10</div>
      <div style="display:flex; gap:10px;">
        <button id="hint" class="btn ghost">üí° Hint (‚àí50%)</button>
        <button id="reveal" class="btn primary">üëÅÔ∏è Reveal</button>
      </div>
      <div style="display:flex; gap:10px;">
        <button id="toggleUnits" class="btn">Toggle MIL/MOA</button>
        <button id="toggleMode" class="btn">Centerfire/Rimfire</button>
        <button id="newRound" class="btn warn">New Session</button>
      </div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('scope');
    const ctx = canvas.getContext('2d', { alpha: true });
    const $ = id => document.getElementById(id);

    // HUD refs
    const HUD = { wind: $('wind'), from: $('from'), range: $('range'), tryV: $('tryV'), avg: $('avg'), unitsAvg: $('unitsAvg'), shotIdx: $('shotIdx'), score: $('score'), high: $('high'), unitsLabel: $('unitsLabel'), modeLabel: $('modeLabel'), round: $('round') };

    // Buttons
    const BTN = { hint: $('hint'), reveal: $('reveal'), toggleUnits: $('toggleUnits'), toggleMode: $('toggleMode'), newRound: $('newRound') };

    // Constants
    const RANGES = [100,200,300,400,500,600,700,800,900,1000];
    const DOPE_MIL = [0.0,0.5,1.1,1.9,3.0,4.2,5.6,7.1,8.8,10.6];
    const MOA_PER_MIL = 3.437746770784939;
    const MAX_H_MIL = 6.0;
    const MAX_V_MIL = 12.0;

    // State
    let units = 'MIL'; // or 'MOA'
    let mode = 'CF'; // CF or RF
    let dpr = window.devicePixelRatio || 1;

    const state = {
      round: 0,
      sessionScore: 0,
      highScore: 0,
      revealed: false,
      hintUsed: false,
      avgAbsHold: 0,
      holdsCount: 0,
      // round vars
      rangeYds: 200,
      windMph: 10,
      windFrom: 120,
      mphGun: 6.0,
      trueElev: 0,
      trueWind: 0,
      guessH: 0,
      guessV: 0,
      // mapping
      pxPerUnitX: 10,
      pxPerUnitY: 10,
      unitsPerPxX: 0.1,
      unitsPerPxY: 0.1,
      dragStart: null,
      hintBand: null // {min,max} (same units as UI)
    };

    function toMOA(mil){ return mil * MOA_PER_MIL; }
    function toMIL(moa){ return moa / MOA_PER_MIL; }
    function snap1(v){ return Math.round(v*10)/10; }
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    function resize(){
      const r = canvas.getBoundingClientRect();
      dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(r.width*dpr);
      canvas.height = Math.floor(r.height*dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0);
      draw();
    }
    window.addEventListener('resize', resize);

    function pickRange(isRF){
      const min= isRF?100:100, max= isRF?400:1000;
      const k = Math.floor((max-min)/50);
      return min + Math.floor(Math.random()*(k+1))*50;
    }

    function tryDopeMil(range){
      if (range<=RANGES[0]) return DOPE_MIL[0];
      if (range>=RANGES[RANGES.length-1]) return DOPE_MIL[DOPE_MIL.length-1];
      for (let i=0;i<RANGES.length-1;i++){
        const a=RANGES[i], b=RANGES[i+1];
        if (range>=a && range<=b){
          const t=(range-a)/(b-a);
          return DOPE_MIL[i] + t*(DOPE_MIL[i+1]-DOPE_MIL[i]);
        }
      }
      return DOPE_MIL[0];
    }

    function mphFromRimfireVelocity(fps){
      const T=[[900,1.0],[980,1.2],[1040,1.4],[1100,1.7],[1200,2.1],[1300,2.5],[1500,3.0]];
      if (fps<=T[0][0]) return T[0][1];
      if (fps>=T[T.length-1][0]) return T[T.length-1][1];
      for (let i=0;i<T.length-1;i++){
        const [x0,y0]=T[i],[x1,y1]=T[i+1];
        if (fps>=x0 && fps<=x1){ const t=(fps-x0)/(x1-x0); return Math.round((y0+t*(y1-y0))*100)/100; }
      }
      return 2.0;
    }

    function windHoldMil(rangeYds, windMph, fromDeg){
      const mphGun = state.mphGun>0?state.mphGun:6.0;
      const s = Math.abs(Math.sin((fromDeg%360)*Math.PI/180));
      const sign = ((fromDeg%360)<180)?1:-1; // 0..179 pushes right
      const mil = (windMph/mphGun)*(rangeYds/1000)*s*sign;
      // spin drift option could be added here
      return mil;
    }

    function startRound(){
      state.round = (state.round%10)+1;
      state.revealed=false; state.hintUsed=false; state.hintBand=null;
      const isRF = (mode==='RF');
      state.rangeYds = pickRange(isRF);
      state.windMph = 2 + Math.floor(Math.random()*19);
      // quartering bias
      const bands=[[60,120],[240,300],[0,360]]; const b = Math.random()<0.7?bands[Math.floor(Math.random()*2)]:bands[2];
      state.windFrom = Math.random()*(b[1]-b[0])+b[0];
      state.mphGun = isRF? mphFromRimfireVelocity(1080) : 6.0;
      const elevMil = tryDopeMil(state.rangeYds);
      state.trueElev = (units==='MIL')? elevMil : toMOA(elevMil);
      const trueWindMil = windHoldMil(state.rangeYds, state.windMph, state.windFrom);
      state.trueWind = (units==='MIL')? trueWindMil : toMOA(trueWindMil);
      state.guessH = 0;
      state.guessV = state.trueElev; // start on DOPE waterline
      updateHUD();
      draw();
    }

    function updateHUD(){
      HUD.wind.textContent = state.windMph.toFixed(0);
      HUD.from.textContent = state.windFrom.toFixed(0);
      HUD.range.textContent = state.rangeYds.toFixed(0);
      HUD.tryV.textContent = snap1(state.guessV).toFixed(1) + ' ' + units;
      HUD.avg.textContent = (state.holdsCount? (state.avgAbsHold/state.holdsCount) : 0).toFixed(1);
      HUD.unitsAvg.textContent = units;
      HUD.shotIdx.textContent = state.round.toString();
      HUD.score.textContent = state.sessionScore.toString();
      HUD.high.textContent = state.highScore.toString();
      HUD.unitsLabel.textContent = units;
      HUD.modeLabel.textContent = (mode==='CF'?'Centerfire':'Rimfire');
      HUD.round.textContent = state.round.toString();
    }

    // scoring model using IPSC zones
    function inchesToMilAtRange(inches, rangeYds){
      const yardsToInches = rangeYds*36;
      const milsPerInch = 1000/yardsToInches; // 1 mil = 1/1000 of range
      return inches*milsPerInch;
    }

    const IPSC = { W:18, H:30, A_W:6, A_H:11, A_TOP:4, D:3 };

    function scoreZone(dxMil, dyMil){
      const halfW = inchesToMilAtRange(IPSC.W/2, state.rangeYds);
      const halfH = inchesToMilAtRange(IPSC.H/2, state.rangeYds);
      const torsoTopOffsetMil = inchesToMilAtRange(IPSC.W*0.40, state.rangeYds);
      const torsoCenterYMil = torsoTopOffsetMil - halfH;
      const lx = dxMil;
      const ly = dyMil - torsoCenterYMil;
      const inTorso = (lx>=-halfW && lx<=halfW && ly>=-halfH && ly<=halfH);
      if (!inTorso) return 'MISS';
      const aHalfW = inchesToMilAtRange(IPSC.A_W/2, state.rangeYds);
      const aHalfH = inchesToMilAtRange(IPSC.A_H/2, state.rangeYds);
      const aCenterY = (halfH - inchesToMilAtRange(IPSC.A_TOP, state.rangeYds)) - aHalfH;
      if (Math.abs(lx)<=aHalfW && Math.abs(ly - aCenterY)<=aHalfH) return 'A';
      const dInset = inchesToMilAtRange(IPSC.D, state.rangeYds);
      const nearEdge = (lx<-halfW+dInset)||(lx>halfW-dInset)||(ly>halfH-dInset)||(ly<-halfH+dInset);
      if (nearEdge) return 'D';
      return 'C';
    }

    function reveal(){
      if (state.revealed) return;
      state.revealed = true;
      const hMil = (units==='MIL')? state.guessH : toMIL(state.guessH);
      const vMil = (units==='MIL')? state.guessV : toMIL(state.guessV);
      const tH = (units==='MIL')? state.trueWind : toMIL(state.trueWind);
      const tV = (units==='MIL')? state.trueElev : toMIL(state.trueElev);
      const dx = hMil - tH; const dy = vMil - tV;
      const zone = scoreZone(dx,dy);
      let pts = (zone==='A'?100: zone==='C'?70: zone==='D'?40: 0);
      if (state.hintUsed) pts = Math.floor(pts/2);
      state.sessionScore += pts;
      state.highScore = Math.max(state.highScore, state.sessionScore);
      state.avgAbsHold += Math.abs(hMil);
      state.holdsCount++;
      updateHUD();
      draw();
    }

    function hint(){
      if (state.revealed) return;
      state.hintUsed = true;
      // show a translucent band ¬±0.2 MIL (or equivalent) around the true wind hold
      const halfBandMil = 0.2;
      const half = (units==='MIL')? halfBandMil : toMOA(halfBandMil);
      const center = state.trueWind;
      state.hintBand = { min: center - half, max: center + half };
      draw();
    }

    function nextRound(){
      if (!state.revealed){ reveal(); }
      state.revealed=false; state.hintUsed=false; state.hintBand=null;
      startRound();
    }

    // pointer interactions
    function mapUnits(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      // circle radius and ladder area similar to app
      const maxHX = (units==='MIL')? MAX_H_MIL : toMOA(MAX_H_MIL);
      const maxVY = (units==='MIL')? MAX_V_MIL : toMOA(MAX_V_MIL);
      const pxW = (w-40) / (maxHX*2);
      const pxH = (h-160) / (maxVY + 2);
      state.pxPerUnitX = pxW; state.pxPerUnitY = pxH;
      state.unitsPerPxX = 1/pxW; state.unitsPerPxY = 1/pxH;
      return { cx: w/2, cy: h*0.46 };
    }

    function onDown(e){ const r = canvas.getBoundingClientRect(); const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top; state.dragStart={x,y,h:state.guessH,v:state.guessV}; }
    function onMove(e){ if(!state.dragStart) return; dragTo(e); }
    function onUp(){ state.dragStart=null; }

    function dragTo(e){
      const r=canvas.getBoundingClientRect();
      const x=(e.touches?e.touches[0].clientX:e.clientX)-r.left; const y=(e.touches?e.touches[0].clientY:e.clientY)-r.top;
      const dx=(x-state.dragStart.x)*state.unitsPerPxX; const dy=(y-state.dragStart.y)*state.unitsPerPxY;
      const maxHX=(units==='MIL')?MAX_H_MIL:toMOA(MAX_H_MIL); const maxVY=(units==='MIL')?MAX_V_MIL:toMOA(MAX_V_MIL);
      state.guessH = clamp(snap1(state.dragStart.h+dx), -maxHX, maxHX);
      state.guessV = clamp(snap1(state.dragStart.v+dy), 0, maxVY);
      HUD.tryV.textContent = snap1(state.guessV).toFixed(1) + ' ' + units;
      draw();
    }

    canvas.addEventListener('mousedown', onDown); canvas.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
    canvas.addEventListener('touchstart', onDown, {passive:true}); canvas.addEventListener('touchmove', onMove, {passive:true}); canvas.addEventListener('touchend', onUp, {passive:true});

    // drawing
    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight; ctx.clearRect(0,0,w,h);
      const { cx, cy } = mapUnits();
      const radius = Math.min(w*0.9, h*0.8)/2;

      // scope bezel
      drawScopeBezel(cx, cy, radius);

      // grid + silhouette + markers inside clip
      ctx.save(); ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.clip();
      ctx.fillStyle = '#0b0e15'; ctx.fillRect(0,0,w,h);
      drawReticle(cx, cy, radius);
      drawSilhouette(cx, cy, radius);
      drawWindArrow(cx, cy, radius);

      // guessed or true dots
      if (state.revealed){
        dot(cx + state.trueWind*state.pxPerUnitX, cy + state.trueElev*state.pxPerUnitY, 4, '#4cd137');
        dot(cx + state.guessH*state.pxPerUnitX,  cy + state.guessV*state.pxPerUnitY, 4, '#ffcc00');
      } else {
        dot(cx + state.guessH*state.pxPerUnitX,  cy + state.guessV*state.pxPerUnitY, 4, '#8ef5b1');
        if (state.hintBand){
          const x1 = cx + state.hintBand.min*state.pxPerUnitX;
          const x2 = cx + state.hintBand.max*state.pxPerUnitX;
          ctx.fillStyle = '#8ef5b133'; ctx.fillRect(Math.min(x1,x2), cy- radius, Math.abs(x2-x1), radius*2);
        }
      }
      ctx.restore();

      // ladder rows (2..12) below disk like the app
      drawLadder(cx, cy + radius + 26, w*0.86);
    }

    function strokeLine(x1,y1,x2,y2,w=1,color='#ffffff55'){ ctx.strokeStyle=color; ctx.lineWidth=w; ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke(); }
    function textAt(t,x,y,align='center'){ ctx.save(); ctx.fillStyle='#a5adbd'; ctx.textAlign=align; ctx.textBaseline='middle'; ctx.font='12px ui-monospace, monospace'; ctx.fillText(t,x,y); ctx.restore(); }
    function dot(x,y,r,c){ ctx.fillStyle=c; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); }

    function drawScopeBezel(cx,cy,r){
      // outer ring
      ctx.strokeStyle = '#202635'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
      // degree ticks + numbers + HALF at 30/330/150/210
      for (let a=0; a<360; a+=10){
        const rad = a*Math.PI/180; const r1 = r-10, r2 = r-4; const major = (a%30===0);
        strokeLine(cx+Math.cos(rad)*r1, cy+Math.sin(rad)*r1, cx+Math.cos(rad)*r2, cy+Math.sin(rad)*r2, major?1.5:1, major?'#ffffff66':'#ffffff33');
      }
      // labels
      const labels = [ [0,'0'], [30,'HALF'], [60,'60'], [90,'90'], [120,'120'], [150,'HALF'], [180,'180'], [210,'HALF'], [240,'240'], [270,'270'], [300,'300'], [330,'HALF'] ];
      labels.forEach(([a,t])=>{ const rad=(a-90)*Math.PI/180; textAt(t, cx+Math.cos(rad)*(r-24), cy+Math.sin(rad)*(r-24)); });
      // MIL label left
      textAt('MIL', cx - r + 22, cy);
    }

    function drawReticle(cx,cy,r){
      const isMOA = (units==='MOA');
      const maxHX = (units==='MIL')? MAX_H_MIL : toMOA(MAX_H_MIL);
      const maxVY = (units==='MIL')? MAX_V_MIL : toMOA(MAX_V_MIL);
      // waterline
      strokeLine(cx - maxHX*state.pxPerUnitX, cy, cx + maxHX*state.pxPerUnitX, cy, 1.2, '#ffffff55');
      // center vertical
      strokeLine(cx, cy, cx, cy + maxVY*state.pxPerUnitY, 1.2, '#ffffff55');
      // horizontal scale
      const step = isMOA?1:0.5;
      for (let u=step; u<=maxHX; u+=step){
        const major = isMOA ? (Math.abs(u%10) < 1e-6) : (Math.abs(u%1) < 1e-6);
        const len = major?16:(isMOA && Math.abs(u%5)<1e-6?12:8);
        strokeLine(cx+u*state.pxPerUnitX, cy-len/2, cx+u*state.pxPerUnitX, cy+len/2, major?1.2:.9, '#ffffff77');
        strokeLine(cx-u*state.pxPerUnitX, cy-len/2, cx-u*state.pxPerUnitX, cy+len/2, major?1.2:.9, '#ffffff77');
        if (major){ textAt((isMOA?u:Math.round(u)).toString(), cx+u*state.pxPerUnitX, cy-12); textAt((isMOA?u:Math.round(u)).toString(), cx-u*state.pxPerUnitX, cy-12); }
      }
      // rows with chevrons
      const rowStep = isMOA?2:1; const chevronEvery = isMOA?10:2;
      for (let v=rowStep; v<=maxVY; v+=rowStep){
        strokeLine(cx - maxHX*state.pxPerUnitX, cy + v*state.pxPerUnitY, cx + maxHX*state.pxPerUnitX, cy + v*state.pxPerUnitY, 1, '#ffffff40');
        if ((v%chevronEvery)===0){
          chevron(cx, cy + v*state.pxPerUnitY, 10); textAt(String(v), cx - maxHX*state.pxPerUnitX + 12, cy + v*state.pxPerUnitY - 10, 'left');
        }
      }
    }

    function chevron(x,y,s){ ctx.save(); ctx.strokeStyle='#ffffffaa'; ctx.lineWidth=1.4; ctx.beginPath(); ctx.moveTo(x-s,y+s); ctx.lineTo(x,y); ctx.lineTo(x+s,y+s); ctx.stroke(); ctx.restore(); }

    function drawSilhouette(cx,cy,r){
      // rectangle body scaled to range
      const halfW = inchesToMilAtRange(IPSC.W/2, state.rangeYds) * state.pxPerUnitX;
      const halfH = inchesToMilAtRange(IPSC.H/2, state.rangeYds) * state.pxPerUnitY;
      const topOffset = inchesToMilAtRange(IPSC.W*0.40, state.rangeYds) * state.pxPerUnitY;
      const torsoCy = cy + (topOffset - halfH);
      ctx.save();
      ctx.fillStyle = '#6b72801a'; ctx.strokeStyle='#ffffff22'; ctx.lineWidth=1;
      ctx.fillRect(cx-halfW, torsoCy-halfH, halfW*2, halfH*2);
      ctx.strokeRect(cx-halfW, torsoCy-halfH, halfW*2, halfH*2);
      // A-zone
      const aHalfW = inchesToMilAtRange(IPSC.A_W/2, state.rangeYds) * state.pxPerUnitX;
      const aHalfH = inchesToMilAtRange(IPSC.A_H/2, state.rangeYds) * state.pxPerUnitY;
      const aTop = torsoCy - halfH + inchesToMilAtRange(IPSC.A_TOP, state.rangeYds) * state.pxPerUnitY;
      const aCy = aTop + aHalfH;
      ctx.strokeStyle='#ffffff44'; ctx.strokeRect(cx-aHalfW, aCy-aHalfH, aHalfW*2, aHalfH*2);
      ctx.restore();
    }

    function drawWindArrow(cx,cy,r){
      // place an arrow just inside the right lower quadrant like the app
      const a = (state.windFrom-90) * Math.PI/180; // rotate to canvas coords
      const inner = r*0.65; const outer = r*0.92;
      const x1 = cx + Math.cos(a)*inner, y1 = cy + Math.sin(a)*inner;
      const x2 = cx + Math.cos(a)*outer, y2 = cy + Math.sin(a)*outer;
      strokeLine(x1,y1,x2,y2,2,'#8ef5b1');
      textAt('FROM', x2 + Math.cos(a)*18, y2 + Math.sin(a)*18);
    }

    function drawLadder(cx, topY, width){
      const isMOA = (units==='MOA');
      const rowStep = isMOA?2:1; const maxVY = (units==='MIL')? MAX_V_MIL : toMOA(MAX_V_MIL);
      const left = cx - width/2, right = cx + width/2;
      let y = topY;
      for (let v=2; v<=Math.min(12, maxVY); v+=rowStep){
        // mid ticks every 0.5 mil (or 1 moa)
        const span = right-left; const minorCt = isMOA? (span/ (state.pxPerUnitX*1)) : (span/(state.pxPerUnitX*0.5));
        strokeLine(left, y, right, y, 1,'#ffffff35');
        for (let i=1;i<Math.floor(minorCt);i++){
          const step = isMOA? 1 : 0.5; const x = left + i*state.pxPerUnitX*step; strokeLine(x, y-4, x, y+4, 1,'#ffffff35');
        }
        textAt(String(v), left-12, y, 'right');
        y += 24;
      }
    }

    // UI actions
    BTN.reveal.onclick = reveal;
    BTN.hint.onclick = hint;
    BTN.toggleUnits.onclick = () => {
      const conv = (units==='MIL')? toMOA : toMIL;
      state.guessH = conv(state.guessH); state.guessV = conv(state.guessV); state.trueWind = conv(state.trueWind); state.trueElev = conv(state.trueElev);
      units = (units==='MIL')?'MOA':'MIL';
      updateHUD(); draw();
    };
    BTN.toggleMode.onclick = () => { mode = (mode==='CF')?'RF':'CF'; updateHUD(); startRound(); };
    BTN.newRound.onclick = () => { state.round=0; state.sessionScore=0; state.avgAbsHold=0; state.holdsCount=0; startRound(); };

    window.addEventListener('keydown',(e)=>{ if(e.code==='Space'){ e.preventDefault(); if(!state.revealed) reveal(); else nextRound(); } });

    // boot
    resize(); startRound();
  })();
  </script>
</body>
</html>
